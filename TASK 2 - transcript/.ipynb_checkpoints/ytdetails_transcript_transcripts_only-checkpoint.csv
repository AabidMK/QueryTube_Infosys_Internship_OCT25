videoId,transcript
bshe96X5KkA,"[Music] AI is everywhere, but have you actually built something with it? In this course, you will learn how to build real AI powered features like the ones you see in apps from Google, Amazon, and beyond. We'll start by building a solid foundation, understanding language models, tokens, context windows, choosing the right models, model settings, and prompt engineering. Then we'll build projects starting with a chatbot that can answer questions about an imaginary theme park, helping visitors find what they need faster. Next, we'll create a tool that analyzes customer feedback and delivers clear, actionable insights so users can make shorter decisions in seconds. And finally, we'll wrap up with powerful open-source integrations you can run anywhere. Along the way, you will learn clean architecture principles, follow best practices, and work with modern tools like Bun, Tailwind, Shatian, Prisma, and Olama. By the end, you will have the skills and confidence to build AI powered apps people actually want to use. Watch the full video on my YouTube channel."
PtETUYa3i2Q,"[Music] AI is everywhere, but have you actually built something with it? In this course, you will learn how to build real AI powered features like the ones you see in apps from Google, Amazon, and beyond. We'll start by building a solid foundation, understanding language models, tokens, context windows, choosing the right models, model settings, and prompt engineering. Then we'll build projects starting with a chatbot that can answer questions about an imaginary theme park, helping visitors find what they need faster. Next, we'll create a tool that analyzes customer feedback and delivers clear, actionable insights so users can make shorter decisions in seconds. And finally, we'll wrap up with powerful open-source integrations you can run anywhere. Along the way, you will learn clean architecture principles, follow best practices, and work with modern tools like Bun, Tailwind, Shatsen, Prisma, and Olama. By the end, you will have the skills and confidence to build AI powered apps people actually want to use. I'm Mash Hamadani, a software engineer with over 20 years of experience, and I've taught millions how to code and become professional software engineers through my YouTube channel and online school, codewithmarsh.com. If you're new here, make sure to subscribe as I upload new videos all the time. Now, let's jump in and get started. [Music] Before we dive in, let's talk about what you'll need to know to get the most out of this course. The ideal student is someone who already knows the basics of front-end development and wants to bring AI into their applications to make them more engaging and smarter. That means you should be comfortable with modern JavaScript and TypeScript things like arrow functions, destructuring, promises, and async and await. You should also know how to build simple React applications. You should know how to create components, work with JSX, and use the state and effect hooks. Just the basics. You don't need to be a React expert. If you know a bit of backend development and databases, that's great, but not required. The same goes with AI. You don't need any prior experience. I will walk you through everything step by step. If that sounds like you, you're ready to get started. [Music] Assuming that you're the right student for this course, let me give you a quick overview of how it's structured and what to expect. First, let me tell you what this course is not. If you're looking for one of those build an app with AI in 1 hour miracles, you know, where you paste a few prompts into chat GPT, sit back with the latte, and poof, your billion dollar startup is ready. This isn't that course. We are not doing VIP coding here. We're building smart features with AI, the kind that actually make your apps more useful and more engaging. And we'll do it the right way so you understand exactly what's going on under the hood. All right, here's how the course is laid out. In section one, we'll start with the foundations. You'll learn what language models are, what they can do, and how to work with them. We'll talk about tokens, context windows, model settings like temperature, and how to call models. This section sets you up with the concepts you need before we dive into building. Section two is all about setting up a modern full stack project from scratch. Now, we could use Nex.js JS here, but I decided not to because not everybody uses it or even likes it and some developers prefer to keep the front end and back end completely separate. So in this course, we'll keep the back end and front end completely separate. This helps you clearly see how the two parts talk to each other. We'll use a modern stack with bun, express, react, tailwind, and chaten. And don't worry if you haven't used these tools before. I'll teach you everything from scratch. Now, if you prefer Nex.js, JS, you can still apply everything you learn in this course to a Next.js project. The principles are exactly the same. Section 3 is our first big project, a chatbot that can answer questions about an imaginary theme park to help visitors find the information they need faster. We'll start with the back end, build it step by step, and then refactor it using clean architecture principles. Once the back end is solid, we'll build the front end the same way. We'll add features, improve the UI, and make the chatbot better with each lesson. This is where I want you to code along with me. Don't just watch. Understand the code, the problems we run into, and why we solve them the way we do. If it feels like I'm going too fast, just watch one lesson at a time, take notes, and then repeat it. The lessons are short and focused, so you won't need to remember a lot at once. In section four, we'll dive into prompt engineering, the art of writing prompts that actually get the results you want. You will learn how to give context, control output format, use examples, handle errors, and reduce hallucinations. Section five is another full stack project. This time, a product review summarizer. You have probably seen this on a lot of websites. A quick summary of reviews so you can decide faster. We'll build our own version from scratch, complete with a database and Prisma migrations. It's a bigger, more complex project than the chatbot. So, we'll get to explore a lot of techniques and best practices that most courses skip. And here's the cool part. What you learn here isn't just for summarizing text. You can apply the same techniques to build all kinds of AI powered features. Finally, section six is about working with open-source models. You'll learn why they matter, how to find them, how to run them locally, and how to integrate them into our applications. This opens up a whole new world where you're not tied to commercial APIs. Now, throughout the course, I'll share tips, tricks, and shortcuts you don't want to miss. That's why it's important to watch every lesson in order and code along, especially during the projects. This is a hands-on course, and you will get the most out of it by being active from the very beginning. Oh, and by the way, what you're watching here on YouTube is actually the first two hours of my full 7-hour course. I'm giving you this part for free so you can get a feel for my teaching style and see if you want to go deeper. Next, we're going to set up our development environment. [Music] Before we dive into coding, let's quickly set up our development environment. First, make sure you have the latest version of Node on your machine. So, open up a terminal window and run node-v. Look, on this machine, I'm running node version 22.17. So, make sure you have the same version or higher. If not, head over to node.js.org and download the latest version. Now, for coding, we'll be using VS Code. You're welcome to use your preferred editor, but I highly encourage you to use VS Code because throughout the course, I'm going to show you a lot of cool shortcuts and useful plugins that not only help you write code faster, they also make your job more fun and enjoyable. So, that's all you need for now. Node.js and VS Code. We'll install any other tools as we go through the course. All right, with your environment ready now, let's get started. [Music] Welcome back. In this section, we'll lay the foundation for everything we'll build in this course. We'll explore what language models are, what we can do with them, and how to use them effectively in real world applications. We'll also cover practical concepts like tokens, cost, model selection, and key settings that shape the model's behavior. Even if you have used Chat JP before, this section will give you a solid mental model. So, when we start building, you'll know exactly how and why things work the way they do. Now, let's jump in and get started. [Music] Since Chat JPT came out, the software world has changed fast. New models are being released every month, new tools, new APIs, new expectations, and new job titles. One of the most exciting ones is AI engineer. You have probably seen it pop up in job postings. But what exactly is that? Well, it's not the same as a machine learning engineer. Machine learning engineers build and train models. They clean data, tune architectures, and optimize training pipelines. It's mathheavy and research focused. AI engineers, on the other hand, use pre-trained models, especially large language models, to build smarter applications. They don't need to understand the math behind the model. They need to understand how to use it and how to integrate it into real world apps. It's a lot like using a database. As a software engineer, you don't need to know how MySQL works internally. You just need to know how to query it, structure your data, and build a reliable product. In the same way, as an AI engineer, your job is to understand how to use these powerful AI models to solve real problems. Right now, companies around the world are hiring engineers who know how to build AI powered features. things like summarization, translation, intelligent search, automation, and personalized UX. Let me show you just a few examples. Amazon now shows an AI generated summary of product reviews on the product page. This saves shoppers time and increases conversion by making the buying decision faster. You'll see the same pattern in many other applications where AI is being used to surface quick takeaways from long threads. As another example, Active Campaign, which is a marketing platform, lets marketers use AI to generate full email campaigns with just a few prompts. Instead of starting from scratch, they get instant draft content they can publish and send. Here's another example. On Twitter or X, if you see a post in another language, you'll often see a translate link. Behind the scenes, a large language model detects the language, determines your local, and generates a translated version instantly. This feature is becoming standard across social platforms and news applications. Here's another example. Platforms like YouTube and Twitch use AI to automatically flag things like spam, hate speech, or inappropriate content. It helps keep communities safe without needing thousands of human moderators watching everything in real time. Here's another example. Freshesk, which is a customer support platform, uses AI to automatically categorize, prioritize, and route incoming support tickets. So instead of agents manually sorting through every request, the system sends each ticket to the right team. And that means agents spend less time organizing and more time solving. Let's look at another example. On Redfin, which is a platform for finding homes, when we are viewing a property listing, there's a built-in chat assistant that can answer questions about that specific property. So, instead of waiting to talk to an agent, users can get the basic info they need right away. And these are just a few examples. The possibilities are endless. Everyday developers are adding smart features like these into their applications. Not just for novelty, but to save time, reduce costs, and build smarter, more helpful experiences. I believe that going forward, every software engineer will be expected to know how to work with AI models just like we're expected to work with databases today. You will need to know about large language models or LLMs, prompt engineering, retrieval, augmented generation or rag, vector databases, building agents, and so on. This course is your first step into that world. So, if you're a developer and you want to keep up with where the industry is headed, you're in the right place. In the next lesson, we'll break down what a large language model actually is in simple practical terms. [Music] Now that you understand why learning AI matters, let's start unpacking the fundamentals. In this lesson, we're going to answer a basic but important question. What is a large language model? Let's break it down. At its core, a language model is a system that's trained to understand and generate human language. There are several language models available today. Some are commercial like GPT by OpenAI, Gemini by Google, Claude by Anthropic, Grock by XAI which is Elon Musk's company. We also have open- source models like Llama by Meta, Mistral by European company also named Mistl and many many more. They're called large because they're trained on massive amounts of text. Everything from books and articles to forums, code, documentation, and more. Through this training, they learn statistical patterns in a language. Things like grammar, sentence structure, tone, common facts, and phrasing. So when we prompt an LLM with, let's say, the capital of France is, it doesn't look up the answer. It simply predicts what a helpful response should look like based on patterns it has seen during training. It's like autocomplete but on steroids. In practice, a large language model is a giant mathematical structure, usually multiple gigabytes in size, made up of billions of parameters. Those parameters represent patterns in language like grammar, facts, tone, and style. These models don't understand language the way we do. They don't have beliefs or intelligence. They're just very good at predicting what comes next. The output is often so well written, so fluent on structure that it feels like there's intelligence behind the scenes. But there isn't. It's just mass and probability based entirely on training data. That's why if you ask chat GPT the same question multiple times, we'll often get slightly different answers. It's not repeating a stored response. It's generating new output each time based on likelihood, not truth. And that brings us to a very important point. Because these models don't understand what they're saying, the quality of training data is everything. If a model is trained unbiased, inaccurate, or lowquality data, its responses will reflect that. That's why some models appear politically biased or why some models give completely false answers with total certainty. It all comes back to the data. These days, many people use language models to generate code and it's impressive at first. But here's the issue. These models are trained on billions of lines of code from public repositories including GitHub. And a huge portion of that code is poorly written, outdated, filled with antiatterns or just broken. The model doesn't know that. It simply learns what's common, not necessarily what's correct or maintainable. So when it generates code, it might look clean, sound confident, even compile, but it could be buggy, insecure, or full of bad practices. That's the danger of blindly trusting model generated code. We get something that looks professional but isn't always reliable. So once again, I want to emphasize that training matters a lot. A model is only as good as the data it's trained on. Garbage in, garbage out. If it learns from clean, highquality code and accurate language data, it performs well. If it trains on messy, biased, or incorrect data, the responses can be misleading or flatout wrong. Now, training a large model from scratch isn't just about data. It also requires enormous amounts of compute power. We're talking thousands of GPUs, weeks, or months of continuous training, and infrastructure that only a handful of companies in the world can afford. That's why most of us don't train models ourselves. As developers, our job isn't to become machine learning engineers. It's to understand how to talk to these models via prompting, how to handle their limitations, and how to integrate them into our applications to build smarter features. Just like we don't need to build our own database engine, we just need to know how to use one. That's the mindset you will develop throughout this course. In the next few lessons, we'll dig deeper into how these models work, things like tokens, cost, and how to pick the right one for the job. [Music] So I told you that as a developer you need to learn how to integrate language models into your applications. Now let me show you what that actually looks like. Think about a typical application structure. We have a front end maybe built with React or something similar, a back end, a database for storing our application data and now a language model ready to generate or process content. The LLM is usually not the center of our application. It's a supporting system. We send it input or a prompt. We get a response and use that response to enhance the user experience. And the way we use it depends on our feature. For example, a very common use case is summarization. I showed you how Amazon uses that to summarize reviews. This is getting very common in modern applications. We can also use LLMs for generating content like emails, product descriptions, social media posts and so on. Another common use case is text classification. We can use a model to categorize input. For example, is this spam or not? Is this review positive or negative? Is this support ticket about billing, login or cancellation? We can ask LLMs to generate responses as JSON objects like this. That means our back end can easily parse the response, store it and make decisions based on it. We can also use LLMs for translating text from one language to another. I showed you how Twitter or X does this. Also, the new iOS does that to translate texts in real time. Another great application of language models is in extracting information. For example, we can give an LLM some messy text like a PDF and ask it to pull out structured data like invoice number, amount, names, addresses, and so on. We can also use LLMs to build and integrate chat bots into our applications. We can build chat bots that answer questions based on user data or business documents and so on. All of these use cases follow the same pattern. Text in, text out. We give the model a prompt and it gives us back a response. The response can be plain text. It can be an array, a JSON object, a number, an image, or whatever is useful. Now that you have seen what LLMs can do, let's look at what's actually inside them. In the next lesson, we'll talk about how these models work under the hood. [Music] Now that you know what language models are and what we can do with them, let's take a closer look at something that plays a big role in how we use them effectively, and that's tokens. What are tokens? Well, when we send a prompt to a language model, it doesn't process the input as plain text. Instead, it breaks the text down into smaller units called tokens. These tokens can be whole words, parts of words, punctuation, even emojis or spaces. So tokens aren't the same as characters or words. They fall somewhere in between. To see this in action here on Google, search for OpenAI tokenizer. On this page, you can type a prompt here or click show example. Look, this piece of text has 252 characters and it's broken down into 53 tokens. Down below you can see these tokens colorcoded. So each piece represents a token. Now why does this matter? Because tokens directly impact cost. Let's take open as an example. At the time of this recording, generating 1 million output tokens with GPT40 mini costs 60. With GPT4.1, the same task would cost $8. That's 13 times more. So if you're summarizing long documents or generating large amounts of content, token usage and therefore cost can add up quickly. That's why when choosing a model, cost should be one of the key factors. We shouldn't just go for the latest or most powerful model. Think about what your app actually needs. It's kind of like buying a phone. You don't always need the latest iPhone Pro Max. Sometimes a mid-range phone gives you everything you need. Same logic applies here. So tokens cost money, but there's also a limit to how many tokens a model can handle at once. That limit is called the context window. The context window includes our prompt, which is the input, the model's response, and the chat history. That's if we're building a conversational experience. Again, all of this is measured in tokens. For example, GPT4 Mini has a context window of about 128,000 tokens. GPT 4.1 can handle around 1 million tokens. Mistrol, which is an open-source model, supports around 32,000 tokens. So, if we send a very long prompt and hit the token limit or the context window, the model will stop even in the middle of a sentence. That's why it's important to know how much context our model can handle. But again, we don't always need the largest context window or the biggest model. Mistrol, for example, might be perfectly sufficient for tasks like summarizing a blog post or classifying a support ticket. It all depends on the needs of our application. In the next lesson, I'm going to show you how to count tokens programmatically so we can estimate cost and stay within limits before sending a request. [Music] All right. Now, let me show you how to count tokens in code. So, open up a terminal window. Let's go to our desktop or somewhere on your machine and create a directory called playground. This is going to be our playground project. Next, we cd into this directory and run npm init-y to create a package.json file without answering basic questions about our project like its name, version, and so on. So, here's our package.json file. Great. Now we're going to install a library called tick token. This is the tokenizer used by open AI models. So different AI models, different platforms have their own tokenizer library. Okay, good. Now to open this in VS Code, we're on code space period. Now if this doesn't work on your machine, just drag and drop this directory onto VS Code. All right. Now we add a new file here, index.js JS on the top we import a function called get encoding from tick token. Next we call get encoding and give it an argument. The argument is an encoding. Here we have a few options. These options or these encodings are dictionaries that map token ids to the actual tokens. For example, we might have a token ID let's say 9004 that maps to the word hello. Okay. So we're going to pick CL 100K underline base that is short for chat language and 100K means in this dictionary we have about 100,000 unique tokens. So we get an encoding and store it in a constant. Next we call encoding encode and give it a piece of text like hello world. This is the first test of tick token library. Okay, next we get our tokens and store them in a constant. And finally, we log them on the console. Okay, now let's open up a terminal window here by pressing control and backtick. Now let's run our application by running node index.js. All right, we got a syntax error saying cannot use import statement outside a module. Why are we getting this? Because by default node interprets our JavaScript files as common JS modules. In common JS modules we have a different format for importing functions. So instead of this syntax which is called ES module syntax we have a different syntax which is called common.js syntax. So we have to write code like const get encoding equals require t take token that is the common JS format which is older nobody uses that anymore so to tell NodeJS to use the new format we have to go to our package JSON file we can open it right here package.json JSON, we set the type property to module. Okay, now back to the terminal. Let's rerun index.js. All right, look. We got an array of 13 items where each item is a number. Each number is a token ID that maps to an actual token. So when working with large amount of text, we can use the tick token library to count tokens before sending a prompt to a language model. Hey, just a quick reminder, as I told you at the beginning of this video, what you're watching right now is actually the first 2 hours of my full 7-hour course on building AI powered apps. So once you finish this tutorial, if you want to learn more, check out the link in the description to enroll in the complete course. I would love to see you inside. [Music] These days there are hundreds of AI models out there and new ones are released almost every week. So which model should we choose? There is no single right answer. The model we choose really depends on our application and its requirements. In this lesson, I'm going to give you a framework to make that decision. Now, I'm not going to give you a fixed list of model names to choose because model names change quickly. So instead, we're going to focus on the criteria that matter when choosing a model. The first question we need to ask is how smart does the model have to be? If we want to solve complex problems, we want a model with stronger reasoning. But if we just need to extract text, classify a review, or summarize a short paragraph, we don't need the top tier model. A smaller model is good enough to do the job. The next question is, how fast do we need a response? Bigger models are often slower, especially when generating long outputs. If you're building a real-time user experience, like autocomplete, quick summaries, or short form answers, we'll want a faster model. The next question is, what kinds of input and output are we going to send to and receive from a model? Text is the most common, but newer models can also process images, audio, video, or even a combination of those. These are called large multimodal models or LMMs. So if our application involves anything beyond text, for example, describing what's in an image, then we need a multimodal model. The other factor is cost and I told you that this is based on the number of tokens. So if you're processing long documents or generating a lot of content, cost can add up quickly. The next factor is the context window. We talked about this before. That's how much text the model can process at once. And that includes our input, the model's response, and the chat history. If you're building a conversational experience, if you're summarizing long documents, analyzing code bases, or having long back and forth conversations, we need a model with a large context window. The other factor is privacy. If our application is processing sensitive data like patients, medical records, we probably don't want to send that data to OpenAI servers. This is where open-source self-hosted models can help. We'll talk about that later in the course. Now, to see this in action on Google, search for OpenAI models. On this page, we can see the featured models. At the time of this video, we have GPT4.1, O4 Mini, and 03. Now, up here, we can click compare models and compare these three models or any other models you're interested in. Now look, 03 is their most powerful reasoning model. You can see that indicated down here. But this is also the slowest of all three models. So there is no best single model. If you're building an application that requires solving complex problems, then we need a model with strong reasoning capability. But otherwise, if all we want to do is let's say summarize documents or extract structured data, we can go with a simpler model. Now all these three models as you can see are multimodel models because they support text and image as the input. But for the output they can only generate text. So if you need to generate images in our application then we have to pick a different model. At the time of this video we have a model called GPT image one. Now this model can support text and image as the input but it can only generate images in the output. So it cannot generate any text. Now that aside down below you can see the pricing. We have different prices for input and output. So if we need to process large documents like contracts, cost can add up pretty quickly. So always compare the cost of models and go with the one that fits your application. Now moving on below that we have the context window of these models. So this model has the context window of 200,000 token. This other model has a context window of about 1 million tokens. Now, we also have another factor here that's max output tokens. That's the number of tokens that can be in one response. So, this model, even though it has a larger context window, it can process more text or longer conversations, but each response can be a maximum of 32,000 tokens. In contrast, with this model, our responses can be three times larger. The other factor we have here is the knowledge cutoff and that's when the training of these models stopped. So sometimes you can find older models that don't have up-to-ate knowledge of the world but they could be perfect for your application. So once again there is no best model. All right, we're done with this lesson. In the next lesson we're going to talk about model settings and see how different parameters affect the output. [Music] In this lesson, we'll take a look at the settings that control how a language model behaves. So, here on the OpenAI website, on the models page, let's grab GPT 4.1. On this page, you can see all the details about this model like its level of intelligence, the speed, the price of input and output tokens, as well as the modalities. We can also see the context window, max output tokens and the knowledge cutoff date. Now up here we can try this in the playground. First we have to log in. All right. Here's the model playground. Now the first time you want to use this, you have to add credit to your account. So up here, click the settings icon. Then go to the billing page. On this page, you can add your debit or credit card and add some credit to your account. Once you do that, now let's go back to the playground. So, the model is GPT4.1. We can change this to any models. Now, all these models have a few common settings we're going to talk about in this lesson. The first one is text format. Here we have three options. We have text, which is plain text, as well as JSON object and JSON schema. Let's see the differences in action. So I'm going to go with text and send a prompt like give me three benefits of exercising. So this gives us a short answer in plain text. We have all seen this before. Now let's see what happens if we change this to JSON object. Now we repeat the prompt and say give me three benefits of exercising but we also add as a JSON object. Now take a look. The model generated a JSON object with this format. So we have an object with a single property called benefits of exercising which is an array of strings. Now if the response is not colorcoded on your machine, just click this icon. With this you can toggle between plain text and JSON format. Okay. So JSON is useful if you want to parse the response in our application. But what if we expect a different type of JSON object? So instead of having a property like benefits of exercising, let's say we want to have a property like exercise which would be an object with another property called benefits. This is where we can use a JSON schema. So we change the format to JSON schema. In this box, we should define the shape of our JSON objects. Now this format is a little bit complicated. So it's easier to generate it using AI. Here we can describe the kind of JSON object we expect in the response. For example, we can say generate a JSON object like the following. So we want to have an object. In this object, we want to have a property called exercise which would be an object itself. Now inside this object, we want to have a property called benefits which would be an array. So we give it an example and then have it create this schema for us. All right, look. So here's the name of the schema, exercise schema. And here we have more details about this schema. So this is an object with these properties. In this object, we have a property called exercise, which is an object itself with these properties. In this object, we have a property called benefits, which is an array. Here's a description saying a list of benefits associated with the exercise. Next, we have information about the types of items in this object. So, each element or each item is a string. And here's a description of each element. Next, we have the validation properties like required. So, the benefits property is required. And no additional properties are allowed. Of course, we can always change this to fit our application. So, let's go with the schema. Save. Now we repeat the last prompt and say give me three benefits of exercising as a JSON object. All right, take a look. This time the model generated a different kind of JSON object. So we have this object with a property called exercise which is an object with a property called benefits which is an array of strings. So that's text format. Now let's go back to plain text. Then we have temperature. With this we can control how random or creative the response can be. This is a value between 0 and 2. But we never set it to extreme values. Here's a guideline. We use a low temperature like 2 to4 for logical precise answers like summarization, answering factual questions and so on. We use higher temperature like a value between 7 to 1.0 zero for creative expressive tasks like brainstorming, writing, marketing, copy and so on. So it's best to stick to this range. Don't go with extreme values like zero or two because the model can go crazy. Let me show you an example. So here we have set the temperature to two. Now let's say write a story about a robot. Look what happens. The model starts generating a story about a robot. But as we progress, look, it's generating gibberish. There is nonsense coming out because the model is getting extremely creative. This is the problem with really high temperatures. So, a good rule of thumb is to set it to 7. This is a good balance between logical and creative responses. Next, we have max tokens and this sets the maximum length of the response. Now, the value we set here really depends on what problem we're trying to solve. If you want to generate something short like a tweet, we have to go with a lower value. Otherwise, we may waste our tokens and pay more than we need. But when using lower values, keep in mind that the response can be cut off mids sentence. Let me show you. So, I'm going to set max tokens to 50. Now, once again, we're going to say write a story about a robot. All right. So, it says in the quiet town of Maplewood, there was a small robot named Pixel. Pixel was built by a kind inventor, Mrs. Rivera, who wanted to help. But look, the sentence is cut off. So to prevent this, we have to be more precise with our prompt. This is one of the prompt engineering techniques. There are many more techniques we'll cover later in the course. So here we can say, write a story about a robot in 50 tokens or less. Write a complete answer without cutting off mid sentence. All right. Now, with this second story, look, it's saying, ""From that day on, Orbit became the twin's favorite friend. Always helping those in need. Robot heart glowing with happiness."" Beautiful. So, that was Max tokens. We also have top P. This is another way to control randomness, but it works a bit differently than temperature. Let's say as part of generating the response, the current token is ant. And here are all the possible options for the next word. Now next to each token you can see its probability based on the training data. If we set top P to one, we tell the model to use the full range of possibilities. So any of these words or any of these tokens can be used to generate the response. But if we use a lower top P like.3 that makes the model focus only on the most likely next words. So once again, top is another way to control randomness. It works differently from temperature. In practice, we usually change one or the other, but not both. If you're not sure which one to use, stick with temperature and set top P to one. So these are all the common settings. We also have store logs which is used for logging and debugging. By default, it's enabled which means all our prompts will be logged on OpenAIS servers. To see them, we go to the dashboard. Then we go to the logs. On this page, you can see all the prompts we have sent to OpenAI. We have the input, the output, the model, and the date time. If we click any of these items, we can see more details. So up here we can click details. We can see the exact day time as well as the ID of the response. So each response has a unique identifier and this is useful for creating the conversation state. So the model remembers our previous responses. We'll talk about this later in the course. We can also see the model that was used, the number of tokens, the response format, max output tokens, temperature, and so on. [Music] All right. Now, let me show you how we can call models in code. To do that, first you have to create an API key. So, on the top, let's go to the settings page. Then, we go to API keys and create a new secret key. We give it a name. This could be the name of our application like my playground app. Next, we assign it to a project. We have the default project, but we can also create multiple projects and assign different keys to different projects. Now, let's create the key. Good. Let's copy this back to VS Code. We remove all the code here and declare a constant called OpenAI API key. Reset it to this key. Now I got to emphasize this is just for demonstration. In a real application, we should never store API keys in the source code because with that anyone who has access to your source code can use your API key and you'll be the one paying for it. So as a best practice, we should always store the keys outside of our source code using environment variables. We'll talk about that later when we start building projects. Next, we should install the OpenAI library. So we open a terminal window and run npm install open AI. All right, good. Now this library is just a wrapper around open AAI API. So it gives us a class with a bunch of methods that we use behind the scene. It's going to make HTTP calls to the API exposed by OpenAI. If you go to the docs and look at the libraries page, you can see that they also have official libraries or SDKs for JavaScript, Python, Net, Java, and Go. There are also a bunch of libraries built and maintained by community for other languages. So back to the code on the top, first we import the OpenAI class from the OpenAI module. Next, we create an instance of this class. So we declare a constant called client because this is a client to open AAI platform. We set it to a new instance of open AAI and provide an object and here we set API key to open AAI API key. Next we call client responses.create and give it an object. Here we can set the model to let's say GPT-4.1. We set the input to our prompt like write a story about a robot. We can also set the other settings we talked about in the previous lesson like temperature. Let's set it to 7. And we set max output tokens to let's say 50. Now this method returns an API promise. So we have to await it to get the response. So let's await this and get the response. And finally we log the response on the console. Okay. Now back to the terminal. Let's run node index.js. Now the terminal freezes because we are waiting for the response to be generated. But later we'll enable streaming so you can see the response as it's being generated. Okay. Now here we have a bunch of properties in the response. The one we use most of the time is output text. This is the response generated by the model. But we also have a few other useful properties. We have usage where we can see the number of input and output tokens. Now in this case I'm not entirely sure why input tokens is zero but output tokens is 50. We also have top P which is set to one by default. We have temperature. We have store. So this response is logged on OpenAI servers. And also up here we have the unique identifier for this response. Later when we build a chatbot, we'll use this to maintain a conversation state. So the chatbot remembers the conversation history. Now back to the code, let's see how we can enable streaming. To do that, first we set stream to true. Now to see this clearly, let's increase max output tokens and set it to 250. Now when we set stream to true, we no longer get a response object. Instead, we get a stream object. So let's rename this by pressing F2 to stream. Now this stream is what we call an async iterable. What does it mean? Well, an iterable is an object that we can iterate over like an array. So here we use a for loop and say for const event of stream. So we are iterating over the stream getting one event at a time. Now I told you that this stream object is an async iterable. So to iterate over it we have to use the await keyword because these events are generated at runtime. So we don't get them all in one hit. We get them as they are being produced. Okay. So, we iterate over the stream object and then log the event on the console. Now, back to the terminal. Let's rerun our program. All right. Now, look, we're printing these event objects as we are receiving them. Let's scroll off and take a look at a few of them. So, look, each event has a type property. In this case, the type is response.output text.ta. This is the event that represents a chunk of text or a token being generated at runtime type. Each of these events has a sequence number. So this is 252. Next one is 253. Here we have a delta property that is the token that is being generated. So here's one token. Then we have another token. So to print the response in the terminal as it's being generated, we just have to print the delta property. So back to the code, let's print event.ta and rerun our program. So these are the tokens that are being generated. But the problem is at the beginning and at the end we get a bunch of undefined messages in the terminal. The reason for that is because not all events contain the delta property. The delta property only exists in events that contain a chunk of text being generated. But we have other events that represent the beginning and the end of this operation. So the proper way to do this is by checking if event delta is defined then we print it on the terminal. So let's rerun our program. Okay, we're getting this tokens. No more undefined messages. Beautiful. But we don't want to print each token on a new line. The reason this happens is because console.log log always adds a new line character at the end. So to print these tokens next to each other, we have to take a different approach. We have to call process std out which represents the standard output or the console window. This object has a right method. We call this and pass the delta. Now let's rerun our program. Okay, this is the same experience we have when we use chat GPT. So that brings us to the end of this section. In the next section, we'll start setting up a modern full stack project. So, I will see you in the next section. Welcome back. Before we start building, we need to set up a clean, modern, full stack project. One we'll use as the foundation for everything in this course. Now, if you have done any research, you have probably seen tons of templates and GitHub starters for full stack applications. And while some of them are great, I decided not to use any of them. I didn't want this course to depend on someone else's setup or introduce tools we haven't covered. Also, we will not be using Nex.js. In case you don't know, it's a powerful full stack framework built on top of React, but not everybody likes it and it comes with its own learning curve. I didn't want this to be a prerequisite for this course. So, instead, we'll set everything up from scratch using tools like Bun, Vit, and Express. This gives us full control. no hidden magic and a setup that's easy to understand and easy to scale. Along the way, we'll add Tailwind for styling, set up SHA CN UI for components, format our code with prettier, and automate our workflow with Husky. By the end of this section, we'll have a solid full stack foundation that's lightweight, clean, and fully ours. Now, let's jump in and get started. Before we start creating our project, there is a tool I want to introduce that we'll use throughout the course and that's bun. If you haven't heard of it before, bun is a modern JavaScript runtime kind of like Node.js but faster and more integrated. With Node, we typically rely on multiple tools. We use npm to install packages, TS Node to run TypeScript, and something like Nodemon to restart the server when we make changes. With Spun, we get all of that in one tool. It's a runtime, a package manager, a taskr runner, and even a TypeScript transpiler allin one. So, it can run TypeScript files out of the box. And we don't need to install a bunch of extra tools just to get started. Now, if you're more comfortable using Node, that's totally fine. Everything I'm going to show you can be done with Node as well. But if you follow along with Bon, you will probably find the experience cleaner and honestly, a lot more enjoyable. So, head over to bond.sh. And here on the homepage, find the installation instruction for your operating system. Just copy this command and run it in a terminal window. Now follow the instructions in the terminal. So here on Mac, we have to execute this command. Exec/bin/zsh. Now to verify that bon is installed properly, we run bon- version. So on this machine, I'm running bun version 1.2.17. In the next lesson, we'll talk about our project structure. [Music] Now, to create our project structure, we open a terminal window. We go to somewhere on our machine. I'm going to go to my desktop. Next, we create a directory. Let's call it my app or whatever you want. We cd into this directory and run bun in it. This is the same as npm in it. So, it creates a package.json JSON file as well as some additional files. Let's go ahead. First, we answer this question to select a project template. We have blank, react, and library. Let's select blank. So, this created a few files. We have a git ignore file, a rule file for the cursor editor, an index file, a TypeScript configuration file, and a readme file. It also installed TypeScript. So, now let's open this with VS Code. So, here's what we get. We have a directory for the cursor editor. I'm not using cursor, so it's safe to delete this. We have our node modules directory, a git ignore file, a bond lock file, an index file, which is just a console lock statement, our package json file just like a node project, a readmi file, and a typescript configuration file. Now to set up a full stack project, we're going to use something called a workspace, which is a feature built into bun that lets us manage multiple sub projects like a client and a server application from a single place. It's also available in node projects. So by convention, we put our sub projects inside a directory called packages. So here we add a directory called packages and then we add a subdirectory for our client app and one more for our server app. Next we go to our package.json file and declare our workspaces. So here we add a new property called workspaces and set it to an array of strings. Here we type the path to our sub packages. So we go to the packages directory and grab the client directory and one more for the server directory. Now there's a shorthand syntax here. We can replace client with an asterisk to say all directories under packages should be treated as workspaces. So let's delete the second entry. This is good. So our project structure is ready. Over the next few lessons, we'll create the client and server applications independently. Now I also want to initialize a git repository here. So let's open a terminal window and run git in it. Good. And make our first commit. Initial commit. Next we'll create our backend project. [Music] Now to create our server application here in the terminal we go to the packages/server directory and run boninit one more time to create the sub project in this directory. We select blank. Now back to our project here in the server directory. We have the same files you saw in the previous lesson. We don't need the cursor directory. So let's get rid of it and clean up our project. Now back to the terminal. Next we shall install express as our web server. In node projects we run npm install or npmi. In bun projects we run bun at. So with node projects we have two different tools. Node for running our code and npm for installing dependencies. But in bun projects all these features are integrated into bun. So we run bun at express. Okay. We should also install express types for TypeScript as a development dependency. To do that, we run bun at-d types/express. Good. Now back to our project. Look here in the server directory, we have this package.json file. And in this file, we have express as a dependency and also express types as a development dependency. So in this project so far we have two separate package.json files one in the root directory and one inside the server directory. Later when we create the client project we'll also have a package.json file in our client directory. Okay. Now what is interesting about this structure is that in this setup we don't have different node modules in our server and client applications. So we don't have a node modules directory inside the server directory. We only have one at the top level where we have all the client and server dependencies. So right now we have express as well as all its dependencies installed in this directory. Okay. So we have installed express. Now let's create a basic web server. So we go to the server directory and open index.ts. Here on the top first we import the express function from the express module. We call this function and get an object which we call app. Next, we declare a constant called port. We can initialize it from an environment variable. To do that, we use process.n.port. So, if we pass port as an environment variable, we can pick it up here. This is useful in production environments. But otherwise, if this environment variable is not defined, we can give this a default value of 3,000. Next we define a route. So here we call app.get and give it two arguments. A path like a forward slash which represents the root of our web server and a function that gets executed when we receive a request at this endpoint. This function should have two arguments a request and a response. Here we use a lambda function and in this function we just want to send the hello world message to the client. So we call response send and pass hello world. Okay. Now so far we have been writing plain JavaScript code. There is no TypeScript here. But we can annotate these arguments with types. So on the top we can import the request and response types from the express module. And then we can annotate these parameters with request and response. Okay. So we have defined a route and a route handler. Next we should start our web server. So we call app.listen and give it two arguments a port and a callback function that gets executed when the web server is up and running. So again we use a lambda function. And here we can say console.log. Now I'm going to replace single quotes with back tick. So we can use template literal. So here we can say server is running on http localhost port. Now here we use a template literal. So we add a dollar sign and curly braces to insert port dynamically. Okay. So that's pretty much it. Now to run this, we go back to the terminal and here in the server directory, we run bun run index.ts. Okay, our server is running. So if you hold down command on Mac or control on Windows and click this, it opens our web browser. So our web server is set up properly. Beautiful. Now instead of running this command every time, we can define a custom command like on start just like we do with node projects. So let's stop this process by pressing control and C. Now we should go to our package.json file. Here in VS Code, we can hold down command on Mac or control on Windows and press P to quickly find files. If we type package.json, you can see we have two files, one in the root directory and one in the server directory. So here in the server package.json, we define our custom scripts. So we add the scripts property. Here's our first script. We call it start and set it to bun run index.ts. We also define a custom script called dev for running our application in watch mode. So anytime we make changes to our files, bun will automatically restart our web server. We set this to bun run index.ts just like before, but here we use the watch option. Make sure to add this right after bun and before run. Okay, now back in the terminal, let's test our commands. So, first we run bun start because this is a built-in command. Okay, our web server is running again. Let's verify it. Beautiful. Let's stop this and try the other command. Now, dev is a custom command. So, we cannot run bundev. Instead, we should run bun rundev. Now, bun is watching our files. So if we go to the index ts in the server directory and make a small change, let's remove the exclamation mark. This should restart our web server. So if we go back to the browser and refresh, the exclamation is gone. [Music] Earlier in the course, I told you that we shouldn't store API keys in the source code. For example, here we don't want to declare a constant like API key and set it to whatever because with this anyone who has access to our source code can use this API key and we'll be the one paying for it. So the right way to manage API keys is using environment variables. That's what I'm going to show you in this lesson. So let's go back to our terminal window and stop this process. Now if you're on a Mac or Linux, you can use the export command. If you're on Windows, you should use the set command. With these commands, we can set an environment variable which is a variable stored at the operating system level. So we give it a name like open AAI underline API underline key. Now by convention, we use capital letters for environment variables. So we set this to a value like 1 2 3 4. Now back to index.ts. Let's remove this line from here. In this route handler, I want to temporarily return our API key. To do that, we use the process object. We go to env or and access open AAI underline API underline key. Make sure to spell it properly. Now back to the terminal. Let's restart our application and go to the homepage. Refresh. This verifies that we could successfully read the environment variable in our application. Beautiful. But there's a problem with this approach. With this approach, every time we want to start our application, first we have to set our environment variables. And this is very tedious. So this is where we use a library called env to streamline this process. Let me show you how to do that. First we stop this process. Next here in the server package we install env oren. Next we go to our project and here in the server directory we add a new file called env. Now if you look at this git ignore file you can see that env files are by default excluded from our git repository. So in the future when we push this repository to github the variables that we declare here will not be exposed to the public. So this is for our private use here we can set open ai underline api underline key to let's use a different value like abcd to differentiate from the former value. Now to load this in our code, we go to index.ts on the top. First we import object from env module. Then we call env.config. This should be the first line in our module. What this does is it goes in this file. It reads all the variables we have declared here and stores them as environment variables before running our application. You will see that in a second. So back to the terminal, let's restart our application. All right, look. Env is injecting environment variables from our env file. So back to the browser. Let's refresh, but the value has not changed. What's going on? Well, the variable that we declared earlier in the terminal window overwrites the variables that we have declared in our env file. To fix this issue, we have to remove the environment variable we set earlier. So, let's stop this. If you're on Mac or Linux, use onset followed by the name of the environment variable like Open AI underline API key. If you're on Windows, use the set command and set the environment variable to an empty value. Okay, now let's restart our application and refresh the homepage. Okay, here's the updated value. Beautiful. So now I'm going to replace this with my actual API key. So back to our env file, I'm going to replace ABCD with a real API key. Beautiful. Now there is a problem here. The problem is that if we commit our code to a Git repository, someone else cloning this has no idea what environment variables they should set. So to help them here, we duplicate this file and rename it to env.example. Example, this file is not going to be excluded from our Git repository so others can see what variables they should set. In this file, we keep the variable names, but we remove the actual values. Now, the last part, back to index.ts. Let's revert this code back and return hello world to the client. So, we're done setting up our API key. Now the final step we make a commit and say manage open AAI API key. Now one more thing before we finish this lesson. If you make any changes in this env file you have to restart the application. So bund will not detect the changes here which means you have to go to the terminal stop this process and restart the application. So the new values are injected into the environment variables. Next we're going to create our client project. [Music] Now to create our front end application, we're going to use Vit. Vit is a very popular build tool for front-end applications. You have probably seen it before. So here on vit.dev, let's go to get started. On this page, you can see the command for creating a new vit project. So with npm, we run npm create vit at latest. We also have support for bun. Let's copy this command. Now back to VS Code. Let's open a new terminal window. So in this application, we're going to have two terminal windows open. One for the server, one for the client. Now we can rename this for clarity. So I'm going to rename this to server. And the second terminal window to client. We can also color code them if you want. Change color. Let's make the server green and the client yellow is fine. Now let's go to the packages/client directory. Paste that command but don't execute it yet because if you do so vit will create a subdirectory here which is not what we want. So here we add a period which means create the front end application in the current directory. Let's go ahead. First we select our framework which is going to be react. Next we select a variant. We're going to go with TypeScript. Okay. Now, back to our project. Look here in the client directory. We have a typical React project created with Vit. There is nothing magical here. In this directory, we also have a package.json file. So, currently we have three package JSON files. One at the root, one for our server application, and the other for the client application. Now, back to the terminal. The next step is to install dependencies using bun. So we can run bon install or bon i. This installs all the dependencies inside our top level node modules directory. So once again we're not going to have different node modules in client and server applications. All right. Now that the dependencies are installed, we can run our application by running bun rundev. So dev is a custom script that is defined in our client package.json file. Let's review that package.json JSON in the client directory. Look, so here we have these scripts, dev, build, lint, and so on. So let's run our client application. Beautiful. Now let's make sure it's working properly. All right, here's our React project. Lovely. So let's wrap up this lesson by making a commit. Create the front end. [Music] All right. Now, to connect our client and server applications, we're going to go to our server application and define a new endpoint. So, we press command np on Mac or control np on Windows and go to index.ts, the one in the server directory. Now, we're going to grab this route handler and duplicate it. Now, let me show you a cool shortcut on the top under the selection menu. Look, we have this command copy line down. The shortcut on Mac is option shift and down. So with this line selected, if I hold down shift, option, and press down, these few lines get duplicated. Now I'm going to change the path to / API/hello. And instead of returning plain text, I want to return a JSON object. So let's pass an object and give it a property like message and set it to hello world. Now before going further, let's test this. So back to the browser here on our server application. Let's send a request to / API/hello. Okay, this is our JSON object. Beautiful. Now if this is not pretty formatted on your machine, just install this Chrome extension JSON formatter. Now let's move on to the client part. So we're going to go to app.tsx. This is the container for our client application. Now, we're going to delete all the import statements. We should also delete all the code inside this function. But we are not going to manually select these lines. I'm going to show you another cool shortcut. So, we put the cursor on the first line. Now, on the top under the selection menu, look at the shortcut for this command. Expand selection. On Mac, it's control shift command and right. So, with the cursor here, I'm going to hold down shift control and command. Now if I press the right arrow the selection will expand. If I press the left arrow the selection will shrink. Take a look. So I press the right arrow. Now this word is selected. I press the right arrow again. Now the entire line is selected. Let's keep going. Now the entire body of this function is selected but not the curly braces. We can keep going. Now the braces are selected. If we keep going the entire function definition is selected. Obviously that's not what we want. So I'm still holding shift control and command with my left hand. Now if we press the left arrow, we can shrink the selection and delete the code in this function. Now here we're going to declare a state variable. So we use the state hook, initialize it to an empty string, and call it message. Now we're going to write a very basic React code to make an API call. So we use the effect hook. Now I know some people are going to have a heart attack saying this but this is just for a quick demo. There are better ways to make API calls. We'll look at that later in the course. So here we use the fetch function to send a request to / API/hello. Then when the promise is resolved we get the response. We convert it to a JSON object and then we get the data and here we set the message to data message. Now as the second argument to the effect hook, we pass an empty array as our dependencies. So this code is executed only once. This is just basic React stuff. You should be familiar with this concept. And finally, we return a paragraph where we render our message. Now if you run our application, this is going to fail because the API endpoint doesn't exist in our client application. So if you go to our client application and send a request to / API/hello, obviously it's not going to work. This is only available in our server application. So to solve this issue, we're going to set up a proxy to automatically forward all requests starting with /appi to our server application. To do that, we go to vit.config.ts. In this object, we add a server property. Next, we set proxy to an object. And here we map requests from / API to HTTP localhost port 3000. And that means if you send a request to let's say / API/hello, this will be automatically forwarded to localhost port 3000/ API/hello. Okay, so with that in place, let's test our application. Back to the browser. Let's go to our client application. Refresh. There you go. We have the hello world message, but it's displayed in the center of the screen, which is not what we want. So, back to VS Code. Let's go to index.css and delete all these styles. We'll come back and work on styling in the future. So, back to the browser. All right, looking good. So, let's wrap up this lesson by making a commit. And here we say connect the front end and back end. [Music] With our current setup, every time we want to start this application, we have to open two terminal windows. One to start the server using one rundev and the other to start the client using the same command. This is tedious. So in this lesson, I'm going to show you a simple way to start both applications using a single command. First, we stop the client and the server. Now we open a new terminal window. Make sure this is pointing to the root of the project. Here we install a dependency as a development dependency called concurrently. Make sure to spell it properly. With this library, we can start multiple applications using a single command. To do this, we go to index.ts in the root directory. Now, currently, we have a console lock statement. Let's get rid of this. Instead, we import the concurrently function from the concurrently module. We call this function and give it an array of commands. Each command is for starting one application. So, here's one object here. We should set a few properties. The first one is name. We set this to server. Next is command. We set this to bun rundev. This is the command that we run. We're starting our server application. Right. Next, we set cwd or current working directory to packages/server. So, we want to run this command from this directory. Now optionally we can assign a prefix color here because with this approach we're going to have a single terminal window. So to differentiate between client and server messages we can assign them different colors. So for server we can use cyan. Now let's duplicate this again. We put the cursor somewhere here. Hold down shift control command and press right to expand selection. Now the entire object is selected. Now let's duplicate it with shift option and down. Good. Now we add a comma here and make a few changes. So this one is going to be client. Again we run our client application using the same command but from a different directory. Also let's change the color to green. Good. So with this setup to start both applications we should run index.ts from our root directory. Now to simplify things, we're going to go to the package.json file in the root directory and define a custom script here. So scripts, we can define a dev script and set it to bun run index.ts. Now back to the terminal. So we're in the root directory here. We run bun rundev. This started both applications. You can see server messages are in cyan and client messages are in green. Let's make sure our setup is working. So back to the browser, let's refresh. Beautiful. So with this, we no longer need the server and client terminal windows. Let's clean things up and make a commit to wrap up this lesson. Run both apps together. [Music] All right, let's talk about styling our application. To style our application, we're going to use Tailwind CSS. Now, if you haven't used Tailwind before, it's a utility first CSS framework, which means it gives us a bunch of small descriptive CSS classes like flex, PT4, which is short for padding, top four, text center, and so on. So, we can use these classes in our markup to style our elements. With this, all the styling is here. So, we don't go back and forth between a CSS file and a CSS file. Now, some people love this, others not so much. But in this course, our focus isn't on styling, it's on building AI powered features. So, we'll keep styling to minimum. And we'll use Tailwind because it's a very popular framework. And if you're not familiar with it, I highly recommend to learn it because it's something that comes up in job descriptions a lot. So, head over to tailwinds.com. Now let's go to the documentation and follow the installation instructions. So we are using Vit. Let's see what we have to do. First we have to create our project which we have done so far. Next to install Tailwind we have to install two libraries. Now we're not going to use npm. So let's grab these two libraries. Back to VS Code. Let's open a new terminal window and go to packages/client. Next, we run bon add and paste these two libraries. All right, good. Now, back to the documentation. The next step is configuring the vit plugin. So, we're going to go to vit.config.ts, import tailwind CSS on the top, and add it in the list of plugins. So, let's grab this line, copy it, and go to vit.config.ts. We paste it here and then add it in the list of plugins. This is a function so we should call it. Okay. Next, we should import tailwind CSS in our root CSS file. So, let's grab this line and go to index.css. Paste it here. I believe this is the last step. So, that's it. Now we can start our application and start building. So let's go to app.tsx and style this message. Here we set class name. Let's set it to font bold. And by the way, I highly recommend to install Tailwind extension in VS Code to get auto completion here. So here on the extensions panel, search for Tailwind CSS. Okay, this is the extension I'm using. Tailwind CSS IntelliSense 10 million downloads. All right. So, let's try font bold. Here's what we get. That looks good. Now, let's give it some padding. So, we can add in a padding of four, which is equivalent to padding of one ram. So, this utility class is a container for this st padding of one ram, which is 16 pixels. Now, take a look. We have some padding around the text. We can also make the text larger. Let's try text 3x large. Okay, that's better. So, that was the basics of Tailwind. As we go through the course, I'm going to show you some additional features. So, let's wrap up this lesson by making a commit and say setup Tailwind CSS. [Music] All right, we set up Tailwind. Now, we're going to set up a UI component library to speed things up, and that's Shatzen. In case you haven't used it before, it's a collection of beautifully designed, accessible, and customizable components. Here on their homepage at ui.shhatsen.com, you can see various examples. They have all these beautiful modern customizable components that we can easily add to our projects. So, let's follow the documentation. Let's go to the docs. First we select our framework which is vit. Now we have created our project. So let's move on. Next we should add tailwind because chaten is built with tailwind. We can move on from this step. We did it in the previous lesson. We also imported tailwind in our index.css file. So now we should modify our typescript configuration file. Now in the current version of vit projects we have three typescript configuration files. We have to modify two of them. One of them is tsconfig.json. JSON. In this file, we should add the compiler options. So, let's select these few lines. Copy. Now, back to VS Code. Here in the client directory, look, we have three TypeScript configuration files. Here's the base one with base settings that is shared between the others. We have one for our React application or front- end stuff and one for Node, which is used for tooling. So, first let's go to tsconfig.json. and paste compiler options. Now back to the documentation. Next, we should modify tsconfig.app.json which is used by our react app. In this file, we already have the compiler options property. So we should only select base URL and paths. Let's copy these. Now let's go to tsconfig.app.json. So here's the compiler options. We just paste these two properties on the top. Back to the documentation. Let's move on. Next, we should update our V configuration file. First, we have to install node types. So, let's copy this line. Back to our terminal. Make sure you're in the client directory. Paste it. Okay. Now, back to the docs. In our V config file, first we have to import path. We should also import tailwind CSS which we did in the previous lesson. So let's just grab the first import statement. Copy it and go to vit config.ts. We paste it on the top. Back to the docs. Now while configuring vit we should add these two plugins react and tailwind which we did before. We just have to add the resolve property. So copy this. And I like to order these alphabetically. So after plugins, I add Resolve. Okay, we're almost there. Now back to the docs. With this, we can run the Shatian CLI. With this CLI, we can easily add components to our project. So we're going to use BONX, which is like npx for running packages. Let's copy this line. Back to the terminal again. Make sure you're in the client directory. Paste it. All right. Chaten is asking what color we want to use as our base color. We have a few options. Neutral, gray, zinc, stone, and so on. What is the difference? Well, back to their website. On the top, let's go to the colors page. Look, this is an example of neutral colors. Then we have stone, which has a warmer tone. We have zinc, which has a cooler tone, slate, gray, and so on. So, that is the difference. I'm going to go with neutral. Now, this CLI created a file called components.json, which keeps track of the components we have installed. Let me show you components.json. It's just some internal stuff. We're not going to modify this. This is used internally by the CLI. Later, when we install components, those components will be listed here. Okay. Now, this CLI also modified our index.css file. Let's take a quick look. index CSS. So in the previous lesson, we only added Tailwind CSS. Now we have a bunch of additional stuff for our theme. So all the base variables for our colors, padding stuff, they're all defined in our CSS file and we can always modify this in the future. Okay, so back to the documentation. Let's move on to the next step. Now you're ready to install components. So if you go to the components page, you can see all the components. In this lesson, I'm going to add a button, you can see a preview up here. You can see an example in the code. Now on the same page, you can see the installation instructions. So we use BONX again to use Shatn CLI to add this button. Let's copy this line and run it in the terminal. Great. Now this button component is part of our project. Take a look. We have all the source code here. We can make any changes we want. All these classes are Tailwind classes. So, we can customize this button to achieve the look and feel we're looking for. Okay. Now, let's see how we can use this. So, we go to app.tsx. First, let's wrap this expression in parenthesis so we can break it down into multiple lines. Now, below the paragraph, I want to add a button. So, we add a button component. This is defined in components/ UI/button. Let's import it. We give it the text like click me. Now, because we have multiple elements, we have to wrap them inside a root element. Okay, back to the browser. Here's what we get. Beautiful. But the button is too close to the edge of the screen. So let's convert this to a div and give it a class of P4. Now we can remove P4 from our text. Now take a look. Okay, that's better. So let's wrap up this lesson. We make a commit and say setup shaden UI. [Music] In this lesson, we're going to set up Prettier. Prettier is a tool that automatically formats our code, so we don't have to think about things like spacing, indentation, or semicolons. That means fewer distractions, fewer style debates, and code that's easier to read for us or anyone else working on this project. So, there are a number of steps you have to follow. Pay close attention to what I'm doing, even if you have set up prettier before. First, we go to the extensions panel and find the prettier extension. If you haven't installed it, go ahead and install it. Next, we're going to define our styling rules. Now, by default, Predier comes with its own rules, but we can override them by creating a prettier rc file. So, here in the root of our project, we add a file called prettier rc. Make sure to spell it properly. Here we add a JSON object where we define our formatting rules. Now, there are a number of settings you can customize. You can look at the prettier documentation, but at a minimum, you want to set single quote to true. This is my personal preference. I prefer single quotes to double quotes. And by that, I'm talking about JavaScript code, not JSON because in JSON, we cannot have single quotes like this. Okay? So, we're going to use single quotes in this project. Next, we set semi to true. That will terminate our lines with a semicolon. Again, my personal preference. Next, we set trading comma to ES5. This setting controls whether or not Prettier adds a comma at the end of the last item in things like arrays, objects, or function arguments when they are written on multiple lines. Now, if we set this to ES5, this tells Priier to add trailing commas where valid in ES5. That means objects, arrays, functional arguments, but not in function definitions or inline arrow functions. Okay. The next setting we're going to set is print width. The default is 80. We keep that. And also tab width, which is the number of spaces for indentation. The default is two. I'm going to change it to three. Now, to see this in action, let's go to app.tsx. Now, in this file, we're using single quotes. I'm going to change these single quotes to double and also remove the semicolon. Now, we're going to go to the command pallet. We can find it under the view menu. The shortcut is shift command and P on Mac. Here search for format document. Now the first time you execute this command, VS code will ask you about the default formatter. Select prettier. Once you do that, format your code. Now look, the double quotes are replaced with single quotes. We have a semicolon and we have consistent tab width. Now we can also configure VS Code to automatically format our code whenever we save our files. To do that we go to the settings. So settings the shortcut is command and comma on Mac. Here search for format on save. Make sure it's enabled with this. If you remove this semicolon but save this file prettier automatically formats this code. Now we can also format our code from the command line. And this is useful before committing our code to git and sharing it with others. To do that, first we have to install Predier as a development dependency. So open a terminal window, a new terminal window pointing to the root of our project. Let's run bon add-er. We add this to the root of our project because we don't want this to be specific to the client or the server application. Okay, let's install this. Next, we go to the package.json JSON file in the root of our project. In this file, we have a script or a command for running both applications. Next, we're going to define a command for formatting the entire codebase. We set this to prettier d-right period, which means start from the current directory. Now, as part of formatting our files, we don't want to format third party code stored in the node modules directory. So here we're going to add a new file in the root of our project called predier ignore. This is similar to git ignore. In this file we can list all the files or directories that should be ignored by predier. So at a minimum we add node modules and also it's good to add bun.lock. This is a lock file used by bun for installing dependencies. We should never touch this. With this in place, now we go back to the terminal in the root of our project and run bun run format. All right. So this formatted all the files in this project. With this we can wrap up this lesson and say setup prettier. [Music] In the last lesson, I showed you how we can format our code before committing it to Git. And I told you that this is a good practice to follow before committing our code to Git and sharing it with others. But there's a problem. What if we forget to run this command before we make a commit? This is where Husky comes in. With Husky, we can automate our Git workflow. So, we can run certain commands like formatting our code or running tests before committing or pushing our code. To get started, go to typicode.github.io. io/husky. Now let's go to the get started page. First we have to install husky as a development dependency. So let's copy this command back to the VS code. Open a terminal window pointing to the root of the project. Let's run this command. Good. Back to the documentation. Next we have to initialize husky. What this does is it creates a pre-comit script in the husky directory. I'll show you that in a second. So let's run bonex husky in it in the terminal window. Good. Now back to our project. So here we have the husky directory. In this directory we have this pre-commit script. In this file we can add any commands that should be executed before committing our code. By default it tries to run one test for running our tests because this is a good practice to follow. But in this project we don't have any tests. So instead we should run bun run format. But there's a problem here with this command we'll format our entire codebase. And that means as our project gets larger as we add more files this operation is going to get slower. But there's a second problem. If we have worked on a certain feature and modified only let's say two files this command will potentially format other files that are not formatted and we'll put them in our commit which can be misleading. So later when we look at our git history, if you open a commit, we'll see a bunch of files that are modified just as a result of formatting. So instead of formatting the entire codebase, we should format only the staged files. To do that, we're going to use a separate library called lint staged. With this library, we can execute tasks on staged files. So back to the terminal, let's install lintstaged as a development dependency. lint dash staged. All right, good. Now, back to our pre-commit script. We're going to replace this command with bonex lint dash staged. So, when we're going to make a commit, we'll run lint staged. Next, we should tell lintstaged what task to perform on what files. To do that, we go in the root of our project and add a new file called lintstagedrc. Make sure to spell it properly. In this file, we add a JSON object where keys are file patterns like we can say any file with any name but with one of these extensions. So in braces we add JS, JSX, TS, TSX and CSS. Now for the value we specify the command that should be executed for stage files that match this pattern. In this case we're going to run prettier d-right. Now earlier we added a period but we're not going to use that here because this will format the entire codebase starting from the current directory but in this case we only want to write or format files that match this pattern. Okay so to recap next time we're going to commit husky will run the pre-commit script in this script we're running lint staged lint stage will look at this file it figures out that it should run prettier on files that match this pattern. Okay. Now, to see this in action, let's go to app.tsx and make a few changes. First, I'm going to add an exclamation mark here, but I'm going to also mess up with formatting and also remove this semicolon. Now, I'm not going to save this file because if I do so, Predator will automatically format this file. In my VS Code, I have set up autosaving. So under file menu we have autosave enabled which means the file is saved but it's not automatically formatted. Formatting only happens when we explicitly save this file. Okay. Now let's go and make a commit. So here we can say setup husky. Now there is a problem at the time of this recording. I believe this is a temporary issue with VS Code. Hopefully that doesn't happen when you're watching this video or maybe this is a problem with my setup. So when I make a commit, look, we get this error saying bonex command not found. Here's what's happening. So VS code is complaining that the bonex command that we have referenced in our pre-commit script cannot be found. Now this doesn't happen if we make a commit from the terminal window. So one way to solve this is by adding all the files here and then making a commit. Let's say setup husky. Okay, the commit is done and now we can verify that our app tsx is formatted. So let's go to app.tsx. Look, the file is beautifully formatted and we have this semicolon here. But what if this happens on your machine and you don't want to commit from the terminal? The solution for that is to replace bonex with npx. So we go to our pre-commit script and replace bonex with npx. I know this is not ideal. is kind of like a hack because we decided to use bun for the entire project. But if you really like the source control panel in VS Code and prefer to make commits this way, you have to replace bonex with npx. Let's make sure this works. So back to appsx again, let's make a change here. Remove the semicolon and mess up with formatting. Let's make a commit. I'm going to say test husky. Okay, no problem. But I'm not going to keep this commit in our history. So back to the terminal. Let's run git log d- one line. So here's our commit history. Now the head pointer is pointing to this commit test husky. We want to get rid of it and have the head point to this previous commit. So the way we do that is by running get reset d- hard. Then we get the head pointer and go one step back. Let's go ahead. Good. Now let's verify that everything looks good. Get log one line. Now the head pointer is pointing to this commit. Beautiful. So we're done with this section. In the next section, we'll start building our first project. [Music] Chatbots are everywhere now. They're becoming a core part of modern applications. So in this section, we're going to build one together from scratch. At first glance, it looks simple. A text box, a send button, and a list of messages. But behind the scenes, there's a lot going on. There's subtle UX details, state management challenges, and edge cases that are easy to overlook if you haven't built one before. So, grab yourself a cup of coffee and let's get started. Now, this section is a little bit longer, so I've broken it down into two segments. In this segment, we'll start by building the backend for chatbot. First, we'll create a basic API that receives a message and returns a response from an AI model. Once that's working, we'll gradually improve it by adding input validation, error handling, and making sure it's robust and clean. Then, we'll reorganize our code to keep things modular and easy to maintain. By the end of this segment, we'll have a fully functional production ready backend ready to plug into our front end. So, let's jump in. [Music] In this lesson, we're going to build a simple API endpoint that receives a message from the user and returns a response. To get started, first we open a new terminal window and go to packages/server and install OpenAI. So, one addi. Good. Next, we go to index.ts in our server application. on the top. First we import open AAI from OpenAI. Once we run config, then we create a new instance of OpenAI with our API key. So let's declare a constant called client and set it to new OpenAI. Here we set API key to we go to process environment and grab open AI underline API underline key. Okay. Next, we define a new endpoint for receiving prompts from the user. So, we call app.post. Now, in this case, we're not going to use that get method because we're not just getting information, we're submitting data to the server. So, we have to send an HTTP post request to this endpoint. Now, for the path, let's go with API/ chat. Next, we add a request handler. So request and response. Now in this function first we should grab the user's prompt from the request. So this request object has a body property. Let's say in the object that we sent to the server we have a property like prompt. We get that and store it in a constant. A cleaner way is to use dstructuring. So instead of accessing the prompt property, we grab request body and dstructure it to grab the prompt property. That's cleaner. Next, we send this to OpenAI. So we call client responses.create. We pass an object. First, we set the model. Now what model are we going to use? Back to the OpenAI website. Look here on the models page. We have different categories of models. We have reasoning models which are used for solving complex multi-step tasks like coding problems. We have another category flagship chat models. They're highly intelligent chat models. Then we have costop optimized models. These are smaller and faster. We also have research models, runtime models, image generation models, and so on. For a chatbot, we can go with one of these costs optimized models because we want a small model that can quickly respond to the user's queries. We don't need reasoning. We don't need to solve complex problems. So for comparison, let's compare a couple of these in terms of their performance and price. I'm going to compare 04 Mini with GPT 40 Mini. So on the top, let's compare models. Here we have 04 Mini. Let's also compare GPT-40 Mini. Now Mini has various flavors. We have mini audio, realtime, and so on. We're going to grab this base model. Now compare these two models. So for OMI is the fastest of all these models. It's a multimodal model. So in the input we can pass text and image. Now compare the prices for this model. The price of 1 million input tokens is 15 cents. Now compare that to this other model. It's 10 times more. So it makes more sense to use this model for our chat application. Now, what about context window? The context window of this model is 128,000 compared to this other model. But for a chatbot, let's say this is going to be a customer assistant. Usually, we don't have long conversations. We don't need a very large context window. Users come ask a few questions and move on. So, I believe 128,000 tokens is a good size for the context window. So, back to the code. Let's set the model to GPT-40- mini. Next, we set input to users prompt. It's good to set a temperature. Now, in the chatbot, responses should be accurate and consistent. We don't need creativity here. So, we should stick with lower temperatures somewhere between 2 to 4. I'm going to go with 02, but we can always modify this in the future. There's no hard and fast rule. This is more an art than science. We have to test different temperatures to see what kind of responses we like more. Now, it's also good to set max output tokens, otherwise the responses are going to be long. But in a chat application for a chatbot, we should have relatively short responses. So, I'm going to set this to 100 tokens. And again, we can always come back and adjust this. So, we call this method. We await the call and get the response. Because we are using await, we have to mark this function as async. So, we have the response. The final step is to return a JSON object to the client. So we call response.json. We pass an object. And here we add a property like message. We set it to response output text. We're almost done. There's just one step missing. Look in this function. We're extracting the prompt from the request body. By default, this is not going to work unless we tell Express to automatically parse JSON object from the request body. The way we do that is by adding a middleware function. So on the top once we create an app we call app dot use. Here we call express.json. This returns a middleware function that gets executed before passing that request to our request handler. So in an express application we can have one or more middleware functions. These middleware functions can be used for parsing request data, for enforcing security rules, for login and so on. So once we install the JSON middleware, we'll be able to access request.body otherwise this is going to be undefined. In other words, the JSON middleware gets executed before our request handler. It parses the JSON object in the request body and stores it in request.body. We're done with our first step. Next, I'm going to show you how to test this endpoint. All [Music] right. Now to test our API endpoint, let's go to the extensions panel and search for Postman. This is a very useful extension for testing API endpoints. It's also available as a standalone application. In the past, I used to use the application, but recently I've been using the extension more. It's kind of more convenient. So, let's go ahead and install this. Once you do this, go to the command pallet. You can find it under the view menu. The shortcut is shift command and P on Mac and probably shift control P on Windows. Here, search for show Postman. You get this panel. The first time you have to create an account and sign in. I know it's a pain in the neck, but trust me, it's completely worth it. It only takes a minute. With this, we can save your HTTP requests in your account and share them across your different machines, so you don't have to recreate them every time. But you can also share your requests with other members in your team. It's very convenient. We're going to create a new HTTP request. We're going to send a post request to HTTP localhost port 3000/ API/ chat. Next, we go in the body tab, select raw for the type of data we want to send. And from this drop-own list, we select JSON. Now, here we add a JSON object to send to the server. So, we add a JSON object. We give it a property called prompt and set it to let's say what is the capital of France. Let's send this request. All right, we got a response with a status of 200. Now, let me put this side by side so you can see clearly. We can toggle the view mode. So, here's our request and here's our response. We have a message saying the capital of France is Paris. Beautiful. So, our API is working. Let's move on to the next lesson. [Music] Right now, our chatbot doesn't have a memory. So, if you ask a follow-up question, it doesn't remember our previous questions. Let me show you. So here I'm going to change the prompt to what was my previous question. Let's see what it says. It says I can't access previous interactions or questions. So how can we solve this? Well, one very basic way to solve this is by declaring a global variable for keeping track of the last response ID. This is a temporary solution. We're going to do things step by step. So outside of our route handler, we declare a global variable like last response ID. Now in terms of the type, this can be either a string if we have a valid response ID or null. The first time we're going to initialize this to null. Now every time we get a response from OpenAI, we update last response ID, we set it to response ID. Now when calling the create method in this options object, we can pass previous response ID to establish a conversation history. So let's set this to last response ID and test our API again. Back to Postman. Let's start by asking what is the capital of France. It says the capital of France is Paris. Great. Now let's ask what was my previous question. It says your previous question was about the capital of France. Great. So we have built memory into this chatbot. But there is a problem. Back to our code. With this global variable, we can only keep track of the last response ID for one conversation. But in a real application, we can have multiple users and each user can have multiple conversations. So the right way to address this is by using a map or a dictionary. So instead of one global variable, we declare a map. Let's call it conversations. We set it to a new map that here we specify the type of keys and values. I'm going to go with string and string. I will explain what it means in a second. So in this dictionary or in this map, we're going to map conversation ids to last response ID in that conversation. For example, we might have a conversation conversation one and the last response ID in that conversation can be 100. Similarly, we can have another conversation and in that conversation in that thread, the last response ID might be 200. So we're going to replace this single global variable with a map. Now in our route handler first we should get the conversation ID from the body of the request. So let's grab it from this object. Let's call it conversation ID. Now this is the same experience we have in chat GPT. For example, when we ask a new question, let's say what is the capital of France? Look what happens in the URL. This client application created a Gwid or a globally unique identifier to represent this conversation. So the client is sending the conversation ID to the server. Now back to our code. We have the conversation ID. Once we get a response, we should update the last response ID in that conversation. To do that we call conversations set as the key we provide conversation id and as the value we provide response do ID and also when setting the previous response ID we should get the last response ID of the current conversation. So we call conversations that get we pass conversation ID and get the last response ID. Let's test this. So back to Postman, I'm going to start with what is the capital of France. It says the capital of France is Paris. Now I forgot to pass the conversation ID. So let's add conversation ID here. Now we can use a grid or just a simple string like con one. Let's start again. Okay. Now in the same conversation I'm going to ask what was my previous question. Now it's not updating. This is a glitch with Postman extension. I don't know if it happens on your machine or not. But if you go to the raw tab, you can see the updated response. Sometimes it doesn't update on the pretty tab. So if that happens you can simply close this window and reopen it. Alternatively you can use the raw or preview tabs. So here it says your previous question was about the capital of France. Great. Now let's open a new conversation and in that conversation ask what was my previous question. Let's see what happens. Again the pretty tab is not updating. So let's go to the raw tab. It says I can't access previous questions or conversations. Great. Let's ask a different question here and say what is after one. After one, the next number is two. Now let's repeat. What was my last question? It says your last question was what is after one? Now if you ask the same question but go to a different conversation, it says your last question was what was my previous question? So it's properly keeping track of the conversation history. Now back to our code. So using a map, we can keep track of the last response in each conversation. Now in this implementation, we are storing these values in memory. In a real application like chat GPT, we should store these values in the database. But that's more complicated. We're not going to do any database work in this project because we just want to focus on foundations. Later in the course, we have another project that involves some database work. [Music] In the last lesson, we assumed that everything would go smoothly. But in a real world application, we can't rely on that. We need to make sure that the request body contains valid data. More specifically, we want to make sure that prompt is a string between 1 and 1,000 characters. And conversation ID is a valid Gwid or globally unique identifier. just like the GUID we have here on chat GPT. So how can we implement these validation rules? This is where we use Zot. Zot is a very popular data validation library used in React applications. So let's open a terminal window here in the server directory. Let's add Zot. All right, good. Now with Zot, we can define the shape of our objects like incoming request data and easily validate them. So let's go to index.ts. First on the top we import Z from zot. Now down here outside of our route handler, let's declare a constant called chat schema. We set it to Z.Object. And here we pass an object for defining the shape of our incoming request data. So in the request we want to have a property called prompt. This should be a string. So we set it to Z dot string. Now here we can chain various methods for defining validation rules. For example, we can call min to specify a minimum length. Let's say a minimum of one character. Now here optionally we can provide a custom error message like prompt is required. Now, we can chain additional methods for defining additional validation rules. For example, we can apply a max length of 1,00 characters. Now, why do we do this? Because we want to prevent a bad user from posting a large amount of text and potentially bringing down our system or at a minimum, we want to prevent them from wasting our tokens. So, we should always apply constraint on the min and max length of our strings. Again, we provide a custom error and say prompt is too long. Max 1,000 characters. Now, when adding multiple validation rules, I like to break my code down into multiple lines. That makes it easier to see things like this. That's better. So, that's the prompt property. Now, in our request, we also want to have a property called conversation ID. This should also be a string. But here we don't want to apply a min and max length. Instead, we want to make sure that this is a valid UYU ID. That's short for universally unique identifier. So, UYU ID or GWIT, they're the same thing. Now that we have a chat schema, we go to our route handler. The first thing we're going to do is validate our incoming request data. So, here we call chat schema safe parse and pass request. This returns an object. We store it in a constant called parse result. Next, we check if parse result is not successful, then we set the status of the response to 400, which means bad request. This is the standard error code we use when the client sends bad data to the server. Also, in the body of the response, we want to add a JSON object to provide error messages to the client. We can get that object from parse result dot error dot format. Okay. Now finally we return. So the rest of this method is not executed. Now let's test this. So let's go to the postman window. Let's see what happens if we pass an empty string for the prompt. All right. Here's what we get. We get an object with three properties. errors which contains common errors as well as prompt and conversation ID which contain specific error messages for these properties. So for prompt we have an error saying prompt is required and for conversation ID we have another error saying invalid Uyu ID. Now let's see what happens if we pass a few white spaces. So with this we have a string that is at least one character long. But a string with white spaces is not a valid prompt. So let's see what happens. The error for the prompt property is gone which is not good. So to prevent this we have to go back to our schema. And before applying min and max rules first we trim the string. With this we get rid of the white spaces at the beginning or end of our string. Now let's send this request one more time. All right the error for the prompt property is back. Great. So let's pass a valid prompt like what is the capital of France. Now for conversation ID we need to pass a valid Gwid. How do we do that? Well we can install an extension for generating grids. So here search for Gwid or UIU ID. There are a lot of different extensions. I use this one UU ID generator. Now back to our request editor. We put the cursor here. Bring up the command pallet and search for UYU ID. We have two commands. The first one is generate UU ID at cursor. Let's select this command. Now we have this UU ID. Copy to clipboard. Let's replace con one with this valid UIU ID. Now we send this request. Okay, it's gone through and we got a response from OpenAI. [Music] All right. Now that we have added basic input validation, the next step is to handle unexpected errors more gracefully. In this lesson, we'll update our API to catch and respond to runtime errors and return a proper error message to the client. So look on this line where we try to get a response from OpenAI. This line might fail for various reasons. Maybe the network is down. Maybe OpenAI servers are down. Perhaps we run out of tokens. Many different things can go wrong. Right now, we are not handling errors. So, to demonstrate this, I want to add an exclamation mark here to represent an invalid model. Now, let's see what happens when we send a request to our API. All right, we get this HTML document. If you preview it, here's what we get. Error 400. The requested model does not exist. And down below, we have our full stack trace. So we can see on which line this error has occurred. This is not a good response to return from our API. So instead we're going to handle this error and return a proper error message to the client. To do that we're going to add a try catch block in our route handler. So try catch in the try block we add our happy path. So we add all the code for getting a response, updating the conversations map and returning the response. We get all this code and put it inside the try block. Okay. Now because this line for extracting the prompt and conversation ID is closely related to the rest of the code, I want to bring this down and put it inside the try block as well for clarity. Now in the catch block, we handle errors. In case something goes wrong, first we want to set the status to 500, which means internal server error. And then we want to return a JSON object with an error property saying failed to generate a response. Okay, now let's see what happens if we send another request to our API. All right, here's what we get. We get a proper error message that we can show on the client. [Music] Right now there is too much happening in our chat API. We have some code for managing conversation state. We have our schema definition. We have data validation, the call to open AI. There's so much happening in this file. There's no real separation of concerns. Everything is just mixed together. It's kind of like a chaotic closet. It's hard to find a particular t-shirt in this closet. So now we're going to refactor or reorganize our code. Refactoring means changing the structure of the code without changing its functionality. It's like reorganizing a chaotic closet. We're not going to add or remove clothes. We're just going to move everything where it belongs. So we're going to have different sections where each section has one and only one purpose. So over the next few lessons, we're going to refactor our code and introduce a few layers into our application. Each layer will be focused and have a single responsibility. At the very top, we'll have controllers. Controllers are responsible for receiving HTTP requests and returning HTTP responses. They act like a gateway into our application. They're kind of like a receptionist in a building. Below controllers, we're going to have services. And this is where we'll have the actual application logic. For example, in our chat API, the piece of code for calling OpenAI to generate a response belongs to this layer, belongs to a service. Below services, we'll have repositories and this is where we have data. So, anytime we need to get or store a piece of data, we worked with a repository. Where that data exists, we don't care. It could be in the memory or in a database. If you follow this architecture, our codebase is going to be much easier to maintain. If something breaks or needs to change, we know exactly where to look. It also improves readability because each layer or module has one clear purpose and overall it makes our application more scalable because we can reuse and test each piece independently and plug them into new features later without duplicating code. So over the next few lessons, we're going to refactor our code and extract these layers one by one. [Music] So we talked about the layered architecture in the previous lesson. Now in this architecture the direction of dependency between layers is always from top to bottom. So controllers can talk to services and services can talk to repositories but not the other way around. So the most fundamental layer in our application is the repository layer. In this lesson we'll introduce a repository and then in the next lesson we'll introduce a service that will use our repository. So I told you that repositories are for data access. Anytime we need to get or store a piece of data, we should use a repository. Now back to our code. Look here we have this line to keep track of our conversations. And these two statements for getting and storing the last response in a conversation. All these pieces are about data access and should be encapsulated inside a repository. So back to our project here in the server directory we add a new folder called repositories and in this folder we add a new file called conversation repository.ts. Now back to index.ts. First we grab this piece of code for declaring the conversations map. We cut it and move it into our repository. Now in this implementation we are storing data in memory. This is what we call implementation detail. Now when defining our modules we don't want to expose implementation detail. So we don't want to export this constant from this module. Instead we should export what we call the public interface of the module. Let me give you a metaphor. Think of a remote control. A remote control has a bunch of buttons on the outside that we use. But it also has a complex electronic board on the inside that we don't care about. That's the implementation detail and the buttons on the outside are the public interface. So when creating this module, we want to keep the implementation detail private and only export the public interface. In this application, we need two functions for getting and setting the last response ID. So we export a function called get last response ID. We give it a parameter conversation ID of type string. Now we go to our index.ts and grab this piece of code, cut it and move it into our module. And of course we return the result. With this in place we go to index.ts ts and here we call get last response and pass the conversation ID. Similarly, we export another function called set last response ID. We give it two parameters conversation ID which is a string and response ID which is also a string. Now we go back to index.ts ts and grab this statement, cut it and move it into this function. We just have to make a tiny change. All right, good. Now back to index.ts. Here we call set last response ID and give it two arguments conversation ID and response. ID. Now with this change, we have kept the implementation detail private and only exported these two functions. That means this index.ts module doesn't know anything about where the data is stored. Right now it's in memory. If in the future we decide to modify our repository and store the data in a database, this module is not going to be affected because it's only dependent on these two functions for getting and setting the last response ID. There's just a tiny problem here with our current implementation. These two functions look kind of like utility functions. The responsibility or the layer they belong to is not quite clear. So here we're going to take a different approach. We're going to go to our repository. Instead of exporting these to standalone functions, we're going to export a constant called conversation repository. This is an object with two methods. I'm going to grab this function definition, copy it, paste it here. Now, let's also do the same for this other function. So, now we're exporting an object called conversation repository with these two methods. Now, we can remove these functions. Save. Back to index.ts. Now on the top we have these two errors because these functions no longer are exported. So instead we import conversation repository from this module. Now down here we prefix these function calls with conversation repository like this. Now it's quite clear in the code that we're asking the conversation repository to give us the last response ID. So that was our first step. In the next lesson, we're going to introduce the chat service. [Music] All right. Now, we're going to introduce a service and this is where we'll have the actual application logic. So, I told you that controllers act as gateways. A controller receives an HTTP request. It validates it. If it's valid, it calls a service to do the job. So a service shouldn't know anything about HTTP requests and responses. Now here in our chat API up to this point we are working with the request object and down here we are working with the response. So all the code in between belongs to a service. So let's go to our project and here in the server directory add a new directory called services. In this directory we add a new file called chat.service.ts. TS. Now here we export an object called chat service and give it a single method that is send message. Here we need two parameters prompt which is a string and conversation ID which is also a string. Now back to our index module. Let's grab this piece of code for calling OpenAI to generate a response and also this line for updating the last response ID in our conversation. So let's cut these lines and move them to our chat service. Now here we need to import the conversation repository. So real quick. Okay. Now we have an error on this line because we are using the await keyword. So let's mark this as async. We should also bring the client object from our index module. So back to the index module. Now let me show you another cool shortcut. Press command and P on Mac or control and P on Windows. Earlier we used this shortcut to jump to a file in our project. Now here if we type an at sign we can jump to a symbol in this file. A symbol can be a variable, a constant, a function and so on. So here I want to find the client object. There you go. Now we can grab these few lines, cut and move them into this module. Now let's import open AI. Good. Now in this implementation, this client object again is implementation detail. So we don't want to export it outside of this module. So this is the only module in our application where we know what LLM we're going to use. If tomorrow we decide to move away from open AAI and use a different LLM, this is the only module we should modify. So the consumer of this module which is going to be our index module shouldn't know what LLM we are using under the hood. That is the implementation detail and what we are exporting here is the public interface. Okay. So we don't have any errors in this module. Now let's go back to our index module. on the top we can remove this line for importing conversation repository as well as open AAI. So our index module is getting leaner with each refactoring we have been doing. Okay. Now we have an error down here. So first we extract the prompt and conversation ID from the request body. Right after we call chat service dot send message. We give it two arguments prompt and conversation ID. We await the call and get a response. Now here we have an error because I forgot to return the response object from our service. So after we get the response, we update the last response ID in our conversation repository. And finally we should return the response. Okay, no more errors. Everything is working. But there's a hidden problem here. Look here we are getting this response object but this object is specific to the open AI platform. So here we are using the output text property to return a message to the client. But what if tomorrow we use a different LLM like Gemini and the response object we get from Gemini doesn't have a property called output text. So back to our chat service. This chat service object that we are exposing is what we call a leaky abstraction. What does it mean? Well, this is an abstraction over open AAI because it hides the complexity. It hides the details. The consumers of this module like our index module don't know what LLM we are using under the hood. So the chat service is an abstraction over open AAI but it's a leaky abstraction because some of the details are being exposed to the outside to the consumers. In this case we are returning this response object which is specific to the OpenAI platform. That's why we say this service is a leaky abstraction. To solve this problem we have to introduce a new type that would be platform agnostic. This will represent a response from an LLM. So up here, let's define an interface. We can also use a type. It doesn't really make a difference. We call this chat response and give it two properties. At a minimum, we need an ID, which is a string, and a message, which is also a string. Next, we annotate this method with its return type. It should return a promise of chat response. Okay, now we have an error because down here we're returning this response object which is not an instance of the type that we just defined. So we have to return a custom object. Here we add two properties ID which we set to response ID and message which we set to response.output text. So if tomorrow we decide to use a different LLM and that LLM doesn't have an output text property, this is the only place in our codebase we have to modify. In other words, this module, this chat service encapsulates all the details for working with an LLM and exposes a simple interface that is our chat service with the send message method. Okay, now back to our index module. Here we have to change output text to message. Okay, no more errors. Now, one last thing before we finish this lesson. I just noticed that in our chat service, we are using the wrong model. So, let's remove this exclamation mark. Great. We're done with this lesson. In the next lesson, we'll introduce a controller. [Music] Earlier I told you that a controller is a gateway to our application. It receives an HTTP request and returns an HTTP response. As part of this, first it validates the request data. If it's invalid, it returns an error. Otherwise, it calls one or more services to perform some functionality. And finally, it returns a response to the client. So now, we're going to grab all the code inside this function or this route handler and move it to a controller. So back to our project here in our server application, let's add a new directory called controllers. Inside this directory, we add a new file called chat.controller.ts. In this module, we export an object called chat controller and give it a method called send message with two parameters request and response. Now while this code works it's better to explicitly import these types from express. So on the top import type request and response from express. Now back to our index module. Earlier we talked about the shortcut for extending selection. You can find it up here. On Mac it's control shift command and right. So the cursor is here. I'm going to hold shift, control, and command with my left hand and keep pressing the right arrow to extend the selection. Now we have the semicolon, now the entire line. Keep going. We have this entire try catch block. Let's keep going. And now we have the entire body of this function selected. Cut. Let's paste it into our chat controller and save the changes. Now let's see what's happening. So we're using the chat service. Let's import it on the top. We're using await. So let's make this method async. Also, we need the chat schema. So back to our index module. Once again, command P on Mac or controlMP on Windows. We type an at sign and find chat schema. Again we extend the selection, grab this object, cut it and move it to our controller module. Here we need to import Z from Zod. Good. No more errors here. Now in this implementation, this chat schema is implementation detail and this chat controller is the public interface. So the consumer of this module which is the index module shouldn't know what library we are using for validating data. That is implementation detail. In other words, it's none of index modules business. The index module just needs a method for sending a message to the application. How the request is validated doesn't matter. Right now we are using Zot. Tomorrow we might use a different library. If we decide to replace Zot with something else, this is the only module we want to modify. We don't want to modify both this module as well as the index module. Okay, so no more errors here. Now back to the index module. We're going to replace this lambda function with chat controller dot send message. Now jump to the top. Let's remove this unused import statements. So we can press command and period on Mac or control and period on Windows and delete all unused imports. So again, our index module is getting cleaner with each refactoring. But we're not done yet. There's one more refactoring which we'll do next. [Music] Right now, all of our route definitions are in index.ts. That works fine for small projects, but as our application grows, keeping everything one file can get messy. So in this lesson, we'll move our route definitions into a separate file. It's a small change, but it helps keep our code clean, modular, and easier to maintain as we add more endpoints. So, back to our project here in the server application, we add a new file called route.ts. In this file, first we import express from express. Now, back to index.ts. Let's grab all our definitions, cut, and paste them here. Now, here we're using the request and response types. So, let's import them from express import type request and response. Okay, good. Now, in this module, we are not going to work with the app. Instead, we're going to work with a router. So, here we create a router. We set this object to express router. On this router, we register our endpoints. Now, let me show you another cool shortcut. Let's say we want to rename all instances of app to router. With app selected under the selection menu, look at the shortcut for select all occurrences. On Mac, it's shift command and L. On Windows, it's probably shift control and L. So, I'm going to press shift command and L. Now we have multicursor editing. All instances of app are selected. So we press backspace and replace them all with router. Now to jump out of multicursor editing, we press the escape button twice. Okay, good. Now down the bottom, we should import chat controller. Okay, now technically in a real application, we shouldn't have our route handlers. We should only have a reference to a function inside a controller, but we added these earlier for demonstration as part of setting up our full stack project. These are oneliners. I'm not worried about them at this point, so we don't need to change them. Now, finally, at the end, we export the router as the default object from this module. I'm using default because this is the only object we should export from this module. Now, back to our index module on the top. We don't need this line anymore. Let's remove it and also chat controller. Instead, we import router from the current folder / routes. So, we configure our environment variables. Next, we create an application. We use the JSON middleware right after we add our router. Okay, so these three lines are closely related. They're all about setting up our app. They're a little bit different from initializing the port. So I like to add a line break between the two. So we create the app, initialize the port and finally start the app. Now our index module is much cleaner. We only have the necessary code for starting the application. All the details are somewhere else. Now let's review what we have done so far. So we created the routes module where we have our routes or endpoints. Now right now we only have a single file for this purpose. But as our application grows, we might have various route files for different functional areas in our application. For example, we can have a route file for registering all the routes related to products and categories. We can have another route file for managing orders. We can have another route file for admin endpoints and so on. Okay. So in this route file, we are using the chat controller as our route handler. Let's take a quick look at this method. This controller is the gateway to our application. It receives an HTTP request, validates it. If it's valid, it asks the service to do the job and finally it returns a response. Now, in our service, we have the application logic. So, for a chat API, we have the code for calling an LLM to generate a response and updating the last response ID in our conversation repository. In our repository, we only have data access code. There is no HTTP request here. There is no LLM call. There is no middleware setup. So over the past few refactorings, we broke down index.ts into a set of small and focused modules. Each having a single responsibility. The repository has data access code. The service has application logic. The controller acts as the gateway and the routes has all the route definitions. So we're done with implementing the back end. Over the next few lessons, we'll start building the front end. Now that the back end is ready, it's time to move on to the front end. Just like we did with the back end, we're going to build a fully functioning chatbot step by step. And once everything works the way it should, we'll take time to refactor and organize our code to keep it clean and modular. Let's jump in. And that's it for this tutorial. What you just watched is the first two hours of my full 7-hour course on building AI powered apps. If you enjoy this and want to keep going, the full course covers everything in much more depth. You'll find the link in the description. I would love to have you join me in the full course, and I can't wait to see what you will build."
V7TMkZH1AkM,"[Music] Hey friends, I've got something exciting to share. I'm working on a brand new course where we'll build AI powered apps together step by step. We'll start with the basics like what large language models are and how they work, and then jump straight into projects. You'll build a chatbot that can answer real questions, a tool that makes sense of customer feedback in seconds, and even learn how to run open-source models right on your own machine. And don't worry, this isn't one of those watch me paste prompts into chat GPT kind of courses. You'll be coding along with me, learning the techniques, best practices, and modern tools you can actually use in your own applications. If you have been curious about AI and want to add it to your developer toolkit, this course is for you. I can't wait to share it with you. It's coming very soon."
h4FRpDGuJyI,"Microsoft just laid off 6,000 employees and the internet has always freaked out. You have probably seen the headlines. AI is replacing all the developers. Tech is dead. But before we join the panic, let's take a breath and look at what's actually happening. First, let's get something straight. Tech layoffs like this aren't new. They have been happening for years, long before AI was a buzzword. Let me give you a quick history lesson. In 2014, Microsoft laid off 18,000 people after buying Nokia. In 2015, HP cut 30,000 jobs during a big restructuring. In 2016, Intel let go of 12,000 employees as it moved away from PCs. IBM, Yahoo, and plenty of others have done the same. Companies change direction. They restructure. They cut costs. Layoffs like these are about strategy, not science fiction. Take Intel for example. When they cut those 12,000 jobs in 2016, they weren't just shrinking. They were moving into new areas. cloud computing and smart devices. And over time, that shift created thousands of new jobs in those gross sectors. That's what a pivot looks like. Letting go in one area to reinvest in another. But of course, social media clowns turn it into something bigger than it really is. They didn't waste a second before yelling AI took their jobs, developers are finished. And it's not just them. Plenty of news outlets do the same. Spin fear into clicks because fear gets attention. They're not trying to explain what's actually happening. They're just chasing views. Honestly, it reminds me of the vaccine panic a few years ago. Remember that? For a while, everything was the vaccine's fault. Heart attacks, car crashes, even bad weather. Someone stubbed their toe, must be the vaccine. Now, it's AI's turn. Something goes wrong in tech, blame AI. Production goes down, that's AI, too. Same fear, different label. Here's the truth. The tech industry is still growing. Companies still need engineers, not just people who know how to write code. I'm talking about real engineers. People who can think clearly, write clean, maintainable code, understand how systems behave, and solve real world problems. With AI in the picture, we're entering a new chapter of software development. We'll be building tools and platforms we can't even imagine today. And guess what? Those tools will create new challenges. And those challenges will need you, thoughtful, capable engineers to solve them. If you want to keep growing in the industry and stay employable, you need real skills, solid fundamentals, deep understanding of how things work under the hood. Unfortunately, VIP coding has become a trend lately. You have seen it. People pasting prompts into an LLM and calling themselves engineers. They don't understand data structures, design patterns, system design, security, or even how to debug. It's like trying to fly a plane with no idea how the controls work. And here's the thing, companies aren't going to pay you for vibes. They're going to pay you for what you actually know. The demands on engineers are going up, not down. Back in the 80s or '90s, most dev job listings focus on knowing one language, a bit of databases, maybe some basic algorithms. But today, you have to know multiple languages, frameworks, CI/CD, cloud platforms, architecture, APIs, security, automated testing, the list goes on. And tomorrow it'll be even more. If all we can do is copy paste code from a chatbot without understanding how it works, you're not just replaceable. You are irrelevant. So if all the noise lately has left you feeling anxious, don't let it. Don't let the social media clowns get to you. Don't let fear-based headlines distract you. Stay curious, keep learning, keep growing. The future doesn't belong to people yelling on the internet. It belongs to the ones who show up, level up, and keep building. If this gave you some clarity, please share it to help others. Now, let's get back to work and build something great. I will see you in the next one."
EWd3_I4X32g,"[Music] Welcome to part two of the ultimate Spring Boot course. In part one, we covered the fundamentals, things like dependency injection and working with relational databases using Spring Data JPA. With that foundation in place, you're now ready to take the next step, building real world APIs. In this part of the course, we're going to build and deploy the backend for an e-commerce application. We'll build a clean, well ststructured REST API using best practices. You will learn how to implement authentication and role-based access control, how to handle payment processing with Stripe, and how to structure your codebase like a professional developer. If you're looking for a comprehensive, easy to follow, well ststructured and practical course that takes you from zero to hero, this is the right course for you. Just like part one, this course is packed with hands-on lessons, capstone projects, and real world exercises designed to help you truly absorb what you're learning. If you're serious about becoming a Springwood developer, this part will give you the experience and confidence to build and deploy production grade applications. I'm Mash Hamadani, a software engineer with over 20 years of experience. And I've taught millions how to code and become professional software engineers through my YouTube channel and online school codewithmarsh.com. If you're new here, make sure to subscribe as we upload new videos all the time. If you're ready to take your spring boot skills to the next level, let's jump in and start [Music] building. Now, let me explain how I've structured this course so you always know what's coming next and how each section builds on the last. We'll start with a quick introduction to how the web works and how Spring MVC helps us handle web requests. If you have never done web development before, this section is a great introduction and explains all the essential concepts you need to know. Next, we'll learn how to build REST APIs, which are simply the parts of your application that expose data and functionality to clients like your front end or a mobile app. Then we'll move on to validating incoming data. Making sure users don't send us invalid or incomplete information like a product with no name or a negative price. This is a critical part of building reliable APIs. After that, we'll build a shopping cart system just like you would find in a real e-commerce application. You will learn how to let users add products to their cart, update quantities, and clear the cart when they are done. Next, we'll protect our APIs so only logged in users can access certain parts of the application. You will learn how to handle user authentication, password security, and restrict access based on user roles like admin versus regular user. With authentication in place, we'll move on to building the checkout and order features. So, users will be able to place orders and we'll make sure that they can only see their own order history, not anyone else's. Then we'll integrate Stripe to process real payments. We'll generate a checkout page, handle payment results, and make sure everything updates automatically once the payment is complete. Finally, we'll take the whole project live. We'll deploy the application and database to the cloud, configure everything for production, and test the live version using Postman. This way, you will understand how real applications go from your laptop to the real world. By the end of this course, you'll have a productionready e-commerce backend with proper architecture, security, and deployment. But more importantly, you'll have the skills and confidence to build real world Spring Boot applications from [Music] scratch. Before we dive into Spring Boot, let's quickly go over the prerequisites for this course. This is an intermediate level course, so there are a few things you need to be comfortable with to follow along. First, you should have a solid understanding of Java. You should be comfortable with concepts like classes, interfaces, and object-oriented programming. If you need a refresher, I've covered all of these topics in my ultimate Java series. I put the link below this video. Next, you should have a basic understanding of relational databases. You should know concepts like tables, primary and foreign keys, relationships, and writing basic SQL queries. If you need a refresher on databases and SQL, check out my complete SQL mastery course. Again, link is below this video. Now, because this is part two of my spring boot series, you should ideally have completed part one or be familiar with concepts like dependency injection and beans, flyway migrations, entities and relationships, repositories, and writing custom queries. If you're not familiar with these concepts, I highly recommend watching part one of the course before continuing. You'll find the link below this video. Now, assuming that you are the right student for this course, now let's get started. [Music] All right. Now, let's set up our development environment and look at the source code we'll be using in this course. I've created two GitHub repositories for this course. We have the Spring API starter repository, which is the project we built in the first part of the course, but I've done some cleanup and removed some of the playground code we had before. This will be our starting point. So, you will clone this repository and code along with me. Then we have the finished repository which contains the full project we'll build by the end of the course. In this repository, we have a commit for each lesson. So in case you get stuck, you can always compare your code with the code I write in each lesson. So head over to github.com/madani/spring API starter. Now under code, let's grab the URL for this repository. I have set up SSH on my machine, so that's what I'm going to use. But in case you have not set this up properly, you can grab the https URL. Copy this. Now open a terminal window and somewhere on your machine, type git clone and paste the URL. Good. So in this folder, we have spring API starter. Now in this course, just like the first part, I'll be using IntelliJ Idea Ultimate. You can use any ID you like, but I highly recommend IntelliJ because it has built-in support for Spring Boot and makes development a lot easier. Also, throughout the course, I'll be showing you a lot of IntelligJ shortcuts and useful tools that will speed up your workflow. So, if you want to follow along, I encourage you to use Intelligj as well. And by the way, if you're using the community edition, you won't get some of the features I'm going to show you in this course. Okay, so let's go ahead and open our project. All right, here's our project. Let's open it. All right. Here's the project that we built in the first part of the course. But I've done some clean up and removed the stuff we don't need anymore. So here in the source directory, we currently have two packages, entities, and repositories. In the entities package, we have address, category, product, profile, and user. I've removed the tag entity because we're not going to use that in this course. We had it in part one only for you to practice many to many relationships. Now in the repositories package, we have a repository for each of these entities. Our repositories are empty. So we don't have any custom queries here. We'll add them as we go through this course. Okay. Now in the resources directory under migration, we have a single migration. So I merged all of the migrations that we created in the first part into a single migration for creating our database tables. Now let's go to application.yamel and update our database settings. So in this course just like the first part we are using MySQL as our database engine. So make sure you have MySQL on your machine and then set the username and password to whatever you have configured. Now let's run the application with control and R. Intelligj is suggesting to enable annotation processing. This is for Lombok. We covered this in part one. So let's enable that. Good. Now we don't have any errors. Our application started on port 8080. If we head over to localhost port 8080, we get a white label error page because we haven't built the homepage yet. Now back to Intelligj, let's verify that our database tables are created properly. So we open the database window and add a new data source to MySQL. On this window, we set our credentials and set the database name to store underline API. Now let's test the connection. Succeeded. Beautiful. Okay, here's our database. And in this database, we have seven tables. So this verifies that Flyway successfully created our database. Now let me give you a few tips on how to get the most out of this course. This is a hands-on project-based course, which means you should be coding along with Spin right from the start. There is a lot we're going to build and a lot of new concepts to absorb. This isn't a course you can just watch passively. If you really want to learn and retain the material, you need to be active. Now, to keep the course efficient and respect your time, I've edited out long pauses, repetitive typing, and other distractions. You'll also see me use Intelligj's autocomp completion a lot to write code quickly. If you're not fast with your keyboard or if you ever feel like the videos are moving too quickly, here's what I recommend. Watch the lesson once, take a few quick notes, and then go back and code it at your own pace. Now, throughout the course, you will see plenty of exercises and capstone projects. These aren't filler. They're where the real learning happens. If you just watch the videos, you might feel like you're keeping up, but unless you pause and try things on your own, you won't learn much. So, please take the exercises seriously. They will help you build confidence and make everything stick. Quite frankly, this is a big course and there's a lot to learn. Don't feel like you need to rush. Take your time, practice what you learn, and go through it at a pace that works for you. All right, now let's jump in and get started. Welcome back. In this section, we're going to explore Spring MVC. That's a framework within the Spring ecosystem that's designed for building web applications. We'll start by understanding how the web works. In this lesson, we'll cover some of the key concepts and terms used in web development. If you have never done web development before, make sure to watch this lesson. It will give you the foundational knowledge you need to follow along. After that, we'll talk about what Spring MVC is, its building blocks, and we'll see them in action. You'll learn how Spring Boot can be used to build both traditional web applications as well as modern APIs. By the end of this section, you'll have a solid understanding of how Spring MVC works and how to use it to build web applications. Now, let's jump in and get started. [Music] Before we dive into building web applications with Spring Boot, let's take a step back and understand how the web actually works. If you have never done web development before, this lesson will give you the foundational knowledge you need. When you open a website in your browser, your computer called the client sends a request to another computer called the server. The server then sends back a response which the browser displays as a web page. Now this communication happens using a protocol called HTTP which is short for hypertext transfer protocol. It's just a set of rules that computers follow to send and receive data over the internet. So every time you visit a website, your browser sends an HTTP request to fetch the page. The server processes the request and sends back an HTTP response with the content of the page. Now, what's inside a request and a response? Well, an HTTP request typically has a few key parts. It has a method which specifies what action you want to perform. The most common ones are get to retrieve data and post to send data. An HTTP request also has a URL, which is the address of the resource you are requesting, like google.com or amazon.com/roucts. An HTTP request also has headers which contain extra information sent with the request like what kind of browser you're using or authentication details. Now an HTTP request can optionally have a body that contains data for the server. This is used when we need to send information to the server like when we submit a form. Now the response from the server also has a structure. The response has a status code which tells us whether the request was successful or not. There are many status codes but the common ones are 200 which means okay everything worked. We also have 404 that means not found. You have probably seen this before. An HTTP response also has headers that include metadata about the response like the type of content being sent. An HTTP response also has a body and this is the main content returned by the server. It could be a complete web page or just some raw data depending on how the application is designed. Now let's talk about how web pages are structured and how they are delivered to the browser. Web pages are built using a language called HTML which is short for hypertext markup language. HTML defines the structure of a web page like what text appears where where images go and how different elements are arranged. Now there are two ways web pages can be generated and displayed to the user. One way is for the server to generate the entire web page before sending it to the browser. This is called serverside rendering or SSR. Meaning the rendering or generation of a web page is done on the server. So the server builds the page with all its content and structure and then sends it to the client. This is how traditional web applications have worked for a long time. The advantage is that the page loads completely when it arrives and search engines can easily understand it. But there is another way modern applications work. Instead of sending a fully built web page, the server can just send the raw data and let the client or the browser generate the page itself. This approach is called client side rendering or CSR. Meaning the rendering or generation of the page is done on the client. Okay. So in this case, the server doesn't return an HTML page, but instead sends data in a format called JSON. That's short for JavaScript object notation. It's the syntax we use for representing objects in JavaScript. So we represent an object with curly braces and inside the object we have a bunch of key value pairs. So in this approach the server sends data as JSON and the JavaScript code running in the browser then takes the data and dynamically generates the web page. We use JavaScript frameworks like React, Angular and Vue to take care of rendering of the page in the browser. Now this type of interaction where the server provides raw data instead of a full page is made possible through something called an API. An API or application programming interface is simply a way for applications to communicate with each other. In this case the back end exposes an API and the front end which can be built with React, Angular, Vue or other frameworks consumes it to render web pages. But APIs aren't just for front-end applications. Other applications like mobile apps and even AI agents which are getting very popular these days can consume APIs to retrieve and process data. Now you might be asking where does Spring Boot fit into all of this. Well, with Spring Boot we can build both types of backends. We can build a server that generates and returns a full HTML page, meaning SSR, but we can also build a server that returns raw JSON data and allow clients to generate the web page. That's CSR or client side rendering. In this section, I'm going to show you both approaches. But because APIs are the modern approach, for the rest of the course, we'll primarily focus on building APIs with Spring Boot. [Music] Now that you understand how the web works, let's talk about Spring MVC. Spring MVC is a framework for building web applications. It gives us all the tools we need to handle HTTP requests, generate web pages, and return data to clients. It's part of the larger Spring ecosystem, and Spring Boot makes it really easy to use. But why is it called MVC? Well, MVC is short for model, view, controller. It's a popular design pattern for organizing our code and making it clean and maintainable. In Spring MVC, we have three main components, model, view, and controller. The model handles the data and business logic. The view is what the user sees like an HTML page displayed in the browser. And controller is the middleman. It takes a request, processes it, and decides what response to send back. Here's what happens when a user visits a web page in a Spring MVC application. Let's say the user opens example.com/books in their browser. The browser sends a request to the books endpoint. Spring MVC receives the request and passes it to a controller that's listening for requests to the books endpoint. The controller processes the request. It might talk to a database and fetch some data and then it returns a response which can be an HTML page or some JSON data. This is how Spring MVC organizes our code to handle requests efficiently. Over the next few lessons, we're going to see each of these building blocks in action. So, here is the current homepage of our website. We don't have a homepage. Now, let's see how we can use a controller and a view to build a homepage for our website. Back to our project, we go in the source directory main java and in this package we add a new package called controllers. Now in this package we add a new Java class called home controller. Now to make this a controller, we should annotate it with the controller annotation that is defined in the stereotype package. With this annotation, we are marking this class as a bean. We talked about beans in the first part of the course. But let me give you a quick refresher. A bean is an object that is managed by a spring. So when we mark this class with the controller annotation, we're telling Spring that this is a bean. So when the application starts, Spring will be able to create an instance of this class and manage that instance. Okay. Now to handle requests sent to our homepage, we add a method here, public string. That's the name of the view that we want to return. We can call the method anything we want, but by convention, we use index for the homepage. Now here, we should return the name of our view, which should be an HTML file. So let's change this to index.html. HTML. Next, we should annotate this with request mapping and as an argument, we provide an endpoint. A forward slash represents the root of our website. So when the user sends a request to the root of our website, this method will be called and then it will return index.html to the client. Okay. Now let's build this view. So back to our project, we go in the resources directory and add a new directory called static. This is where we add our static resources like HTML pages, CSS files, JavaScript files and so on. Now in this directory, we add a new file index.html. Now to generate HTML content, we type HTML col 5 and press tap. So here we have a basic HTML page. We press tab. And here inside the body element, we add a heading. So we type H1 and press tab. And in between these tags, we type hello world. Now don't worry if you're not familiar with HTML. We're not going to do a lot of HTML work in this course. Okay. Now let's restart our application with Ctrl and R. Good. Back to our homepage. Let's refresh. And here's our homepage. Beautiful. Now, let's add another endpoint. So, back to our home controller. Let's select these few lines and press command and D on Mac or control and D on Windows to duplicate them. Now, we're going to change the other endpoint to /hello. So, if you send a request to the hello endpoint, this other method will be called. Let's change it to say hello. Now, we can return the same view or a different view. For simplicity, I'm going to return the same view. Let's restart our application again. Now, if we hit /hello, we get the same result as before. Now, let's right click on this page and look at page source, we see the full HTML markup for this page. This is what the server has returned to the client. This is serverside rendering or SSR in action. This is how traditional web applications work. But later in the section, I'm going to show you how we can build modern APIs that return only data to the client and then it's up to the client to take that data and generate an HTML page. So, we have created a simple controller that returns a static HTML page. But this page doesn't have any dynamic content. In the next lesson, we'll talk about view templates which let us generate dynamic HTML pages. [Music] In the last lesson, we created a controller that returned a static HTML page. Now, to make this dynamic, we have to use a template engine. A template engine is a tool that allows us to create dynamic web pages by embedding variables and logic inside HTML files. Now, we have several template engines for Java applications. We have JSP, which is short for Java server pages. It's an old technology. Nobody uses that anymore. We also have Freemaker, Mustache, and Time Leaf, which is the most popular template engine for spring boot applications. So, back to our project. Let's add Time Leaf to this project. First, we should go to our palm file. To open that file, we press shift, command, and O on Mac or shift, control, and O on Windows and type pom. Now, in this file, we add a starter dependency. So we press command andn on Mac or control andn on Windows to bring up the generate context menu. Then we select add starter. And here we search for thyme leaf. By the way, it's time leaf. It's not th leaf. I've seen some people call it thy leaf. That's not the right pronunciation. So let's add this to our project. Okay. Now back to our project. Here in the resources directory, we add a new directory called templates. By default, Springwood looks for time leaf templates in this directory. Next, we should move index.html into this new directory. Okay. Now, let's open index.html. Now, time leaf has a bunch of attributes that enhances HTML. With these attributes, we can render content dynamically. But to use those attributes, first we have to define a namespace. So we go to our HTML tag and type XML NS that is short for namespace colon. Now look, Intelligj is suggesting the code we have to add. So we simply press tab to complete the code. So with this we are saying that here we're going to use attributes that will start with th and these attributes are defined by this website timeleaf.org. So now instead of rendering hello world statically we want to render it dynamically. We want to pass the name of a person and render it here. To do that we remove the content. Instead we type th here we can see all the time leaf attributes. The one we're going to use in this lesson is text. And with this we can set the text of an HTML element dynamically. Now we set this to a time leaf expression. First we type single quotes to represent a string. Here we say hello followed by a space. Now we want to concatenate this string with the name of a person. Now we want to insert the name dynamically. To do that we type a dollar sign followed by curly braces and inside the braces we type the name of a variable. In this case name. Now this variable is not correctly initialized. In the next lesson, I'll show you how to use models to pass data from controllers to [Music] views. Now to pass data from our controller to our view, we go back to our controller and we give this method a parameter of type model. Now we have two types here. One is an interface declared in this package spring framework. The other one is a class that is defined in a different package. Make sure to import the first one. So we import this. Now a model is basically a container for data. We can use it to pass data from a controller to a view. So here we call model add attribute and pass two arguments. Each attribute has a name and a value. The name of the attribute should be the name of the variable we have used in our view. So here we provide name and set the value to let's say my name mosh. Now here we have a little warning because Intelligj cannot find this view. Now that we're using time leaf views we should remove HTML here. So Intelligj knows that we are working with the time leaf template with this. If you hold down command on Mac or control on Windows and then click this we can jump directly to the view. Similarly, if you hold down command on Mac or control on Windows and click the variable will jump to the line where you have set that variable. Okay. Now, if you don't want to use your mouse, you can press command and B on Mac or control and B on Windows. Okay. Now, we don't need the second endpoint anymore. So, let's remove this and restart our application. Now, back to the homepage. Let's refresh. and here's my name. So, this is how we can use a template engine to render data dynamically. In the next lesson, I will show you how to return JSON data instead of HTML from our [Music] controller. You have learned how we can use Spring Boot to return HTML pages to clients. But what if we want to return raw data? Let me show you how to do that. Back to our project. Here in the controllers package, we add a new class called message controller. Now, we're going to annotate this with a different annotation, and that is rest controller. Now, rest has nothing to do with having a nap. It's short for representational state transfer. I know it's one of those fancy computer science terms, but in simple words, REST is a set of rules that define how web applications communicate over HTTP. Quite often you hear the terms REST or RESTful APIs. An API is just an interface that allows applications to talk to each other. A REST or a RESTful API is an API that follows a set of standard rules. Okay, so we annotate message controller with rest controller and with this we're essentially building an API. Now we're going to expose this on a particular endpoint. So just like before we add a method here. Now this method doesn't have to return a string. It can return a string. It can return a number or an object. Any kind of data we want to return. First let's return a string. Now let's call this say hello and expose it at slash hello. Okay. Now let's return hello world. Let's restart the application. Now if you go to our browser and hit the hello endpoint, we get hello world. But let me show you something interesting. Let's right click here and look at the page source. Look, we only have the data. Unlike before, we don't have any HTML markup. Now, in this example, we're returning a simple string, but we can return a complex object. So, back to our project. Let's wrap this string inside a message object. We go to our project here in the entities package. Let's add a new Java class message. We give it a field private string text. Now we need a constructor and a getter. We can manually create those or we can use Lombok because we're using Lombok in this project just like part one. So we use all arcs constructor and getter. Now back to our controller. Here we wrap hello world inside a message object. Okay. And of course, we should change the return type to message. Let's restart the application. Back to the browser. Let's refresh. Look, now we have a JSON object. So, this syntax is what we use in JavaScript for representing objects. So, a curly brace represents an object. And here we have a key value pair. The key is text and the value is hello world. So, Spring Boot can automatically convert our Java objects into JSON objects. We don't have to worry about that kind of conversion. Now, here I'm using a Chrome extension. That's why my JSON object is pretty formatted. If you're not getting the same result, install this extension called JSON formatter. Okay. So, this is how we can build APIs with Spring Boot. Now, with this API in place, other applications can consume our data and do whatever they want. For example, a front-end application built with React, Angular or Vue can take this data and generate HTML pages on the client. That's one way. A mobile app can also take our data and show it to the user. But not only that, even an AI agent can take our data and use it as part of implementing an automated workflow. That is why in modern applications, we prefer to build APIs instead of returning full HTML markup to clients. So for the rest of the course, our focus will be on building APIs. In the next section, we'll go deeper into building APIs. We'll talk about handling different types of HTTP requests, processing user input, and returning meaningful responses. So I will see you in the next section. Hey guys, thanks for sticking with me so far. Just a quick break. If you're enjoying this tutorial, I wanted to let you know that this is just the first hour of my complete Spring Boot course. The full course is 9 hours long and takes you way beyond the basics. We'll build the backend for an actual e-commerce application with authentication, role-based access control, shopping cart functionality, payment processing with Stripe, and full deployment to the cloud. So after you watch this tutorial, if you want to learn more and level up your skills, you can enroll in the full course using the link in the description. All right, let's keep going. Welcome back. In this section, we're going to dive into building restful APIs with Spring Boot. If you have ever wondered how backend systems expose data to front-end applications, mobile apps, or even other services, this is where it all comes together. We'll start by creating our first RESTful API and learning how to test it using Postman. Then, we'll explore how to handle dynamic routes, set HTTP status codes, and use DTO's or data transfer objects to structure our responses properly. You will also learn how to customize API responses, extract query parameters, and work with request header and body data. From there, we'll dive into the core crowd operations, and even handle more advanced scenarios like actionbased updates. By the end of this section, you'll have a solid understanding of how to build restful APIs that can power web and mobile applications. So, let's jump in and get started. [Music] In this lesson, we're going to build our first RESTful API. We'll create an endpoint at / users that fetches all users from the database and returns them in JSON format. So, back to our project here in the controllers package, we add a new class user controller. Then, we annotate this with rest controller. Next, we define a method that returns a list. Let's import it a list of user. And this is the user class we have defined in the entities package. Now, Intelligj is suggesting to call this get all users. That's a good name. So, we press tab. Good. Now, in this method, we should use our user repository to fetch the users from the database. If I type user repository and press enter, Intelligj automatically adds this as a field in this class and initializes it using this constructor. But in this project, we are using Lombok. So this constructor is really unnecessary. We can make our code more concise. But here we have to apply the all args constructor annotation. Now back to our method here. We call user repository.findall. find all and return the result. Now we have a compilation error because our method should return a list of user but our repository is returning an iterable of user. Now in case you are not familiar with iterables, iterable is an interface that represents a collection of elements that can be iterated over. It's the parent interface for list. So every list object is an iterable. But not every iterable is a list. Now here we have two options. One option is to convert this iterable to a list. But that's really unnecessary because we don't need any additional functionality that comes with lists. A better solution is to change the return type of the method to iterable. Okay. Now to expose this at / users, we apply request mapping and provide slash users. Now in the previous section I told you that HTTP requests have a property called method which can be get for getting data, post for creating data, put for updating data, and delete for deleting data. We're going to see examples of this throughout this section. For now, we're focusing on get. Now request mapping by default uses the get method. But here we have another annotation that's an alias for request mapping and that is get mapping. So we apply get mapping and provide / users as an argument. It's a little bit shorter than request mapping. So I prefer to use get mapping here. Okay. So this endpoint is ready. Now before testing it, let's populate our database with a couple of users. So here in the database window, we open the users table. Let's add a new user. I'm going to call this user one. User one at domain.com. Password whatever. Let's add one more. User two. User 2 at domain.com with the same password. Now we submit changes. Good. Let's restart our application. Lovely. Now back to the browser. Let's hit the users endpoint. And here are our users. But there's a big problem here. Can you see? It's the password field. Our passwords are exposed to the outside world. But don't worry, we're going to come back and fix this later in this section. So, our first endpoint is ready. Next, I'm going to show you an alternative way for testing our APIs. [Music] Now, while we can call APIs using a browser or even command line tools, a better approach is to use Postman. Postman is a very powerful tool designed for testing and interacting with APIs. So, if you don't have it on your machine, head over to postman.com/d downloads and download the latest version for your operating system. Now, let me give you a quick tour of how Postman works along with a few useful features you need to know. So here on the homepage we can click plus to add a new tab. Now up here we can see the request method. So we have get for getting data. We also have post for creating data, put for updating it, patch and so on. So we can send a get request to our new endpoint. Now down here we have a bunch of tabs for modifying our requests. So we can go to the params tab and add query parameters. We'll talk about this later in the section. We also have authorization. We have headers. On this tab, we can see all the request headers. By default, the autogenerated ones are hidden. We can click and see them. So these headers, as you can see, are key value pairs. For example, user agent represents the browser which is set to Postman runtime in this case. Now, practically speaking, we use headers for including metadata when calling APIs. A common application of this is for including API keys or authentication details. Again, we'll look at this later in this section. Here on the body tab, we can include data when calling an API. And this is useful for creating and updating data. Now, we don't need to make any changes here. So, let's send this request. Now, down here, you can see information about the response. So, the status is 200, which means okay. This is the time it took to get the response. This is the size of the response. And down here you can see the body. This is the same output we had in our browser. Right? But here we also have preview and I believe this only works if you have created an account with Postman which is free. With preview we can see the data in the tabular format. It's pretty useful. Now we also have a tab for viewing the response headers. Again these are key value pairs. For example, we have content type that is set to application/json. This is the type of data that the server is sending to the client. So this is the basics of Postman. Going forward, we'll use this tool for calling our [Music] API. So far we have built a simple API for fetching all users. But what if we want to fetch a specific user by their ID? With restful conventions, we have to expose a new endpoint where we can pass the ID of a user. Let's see how we can implement this. So, back to our user controller. Let's add a new method that returns a user object. We call this get user and give it an ID parameter. The type of the parameter should be long because this is the same type we used as the ID of the user entity. Let's have a quick look here. So in our user class, id is a lock. Okay. Now we have to expose this at a new endpoint. So we call get mapping tab. This is our new endpoint / users / id. Now because id is a parameter, we have to wrap it in braces. And also we have to apply the pass variable annotation here. With this we'll be able to pass ID dynamically to this route. Okay. Now in this method we call user repository. Now Intelligj is suggesting the code. Let's press tab. So we call find by ID. Now in the first part of the course you learn that find by ID returns an optional object. So here we have to decide what should happen if we cannot find this user. There are two options. We can throw an exception or return an alternative value like no. In this case, we're going to call or else and provide null as an alternative value. And then finally, we return the result to the client. Now, currently, we have repeated / users in two places. This is a little bit ugly. We can make our code more concise by mapping our controller to the users endpoint. So, up here we apply request mapping. In this case, we don't want to use get mapping because later we're going to implement other methods for creating and updating users. So we cannot use get mapping. So we apply request mapping and as an argument provide / users. With this we can simplify our code. So we remove / users from here and that means we don't need to pass any arguments. So no parenthesis is needed. And down here again we remove / users. So the argument is slash id. Okay. Now let's restart our application. Back to postman. Let's hit / users / one. Okay. Here's our first user. Beautiful. Now whatever value we pass here by default is treated as a string. But under the hood, spring will automatically convert that value to a long. And that means if we pass a value that cannot be converted to a long like a, we're going to get an error. Okay. Now let's see what happens if we try to fetch a user that doesn't exist. Let's say user 10. We don't get any errors. The body of the response is empty, but the status is 200. This is not restful. In restful convention, if a resource like a user cannot be found, we have to set the status to 404. I'm going to show you how to do that next. [Music] Sometimes we need more control over the response. We might need to customize the headers or change the status code. For example, if a user is not found, we should change the status to 404, which means not found. And this is where we use the response entity class. With response entity, we can customize our responses. Now this is a generic class that is defined in org.spring framework.http package. Let's import it. And as a generic type argument, we pass user. Now we have to do a bit of surgery here. Instead of returning the result immediately, we store it in a variable. Then we check if user is null, we should return a response entity with the status of not found. Now Intelligj is suggesting some code. I don't want to use it yet. So let me show you an alternative way of returning a response entity. We can create a new instance of this class. Now look this constructor has five overloads. The first one takes a status code. Here we have an enum that is HTTP status. In this enum we have all the standard HTTP status codes like not found, accepted and so on. So one way is to create a new response entity object like this. But there is a cleaner way. The response entity class has a bunch of static factory methods for creating response entity objects. So here we can call not found. Now this method returns a headers builder object. So we can call this and if you want we can further customize our headers. We don't really need that. So instead we're going to call build to get a response entity object. And this is the code that IntelligJ was initially suggesting. Okay, that's better. So if the user is not found, we return a new response entity with the status of not found. Otherwise, we return. Once again, we can create a new response entity and pass the user object as well as the status code. But there is a cleaner way. We can use one of the static factory methods. So we call return response entity. Okay. And pass the user. So going forward, we're going to use this approach for creating response entity objects. Now let's restart our application. Okay. Back to Postman. If we try to fetch the user with the ID of 10, look, we get a response with a status of 404, which means not found. Otherwise, if we get the user with the ID of one, we get a response with a status of 200. [Music] Beautiful. We've built a simple API for fetching users, but our API currently has two problems. The first problem is that we're exposing our passwords. That's the first problem. The second problem is less visible. The problem is that we are returning our user entity from our API. And that means if tomorrow we decide to change our database structure and subsequently our user entity, those changes will leak to the outside and can potentially break our clients. For example, if we decide to rename the name field to full name or remove some of these fields, these changes will leak to the outside and can potentially break some of our clients. So, as a best practice, we should try to keep our APIs as stable as possible. And if we need to introduce any kind of changes, we should properly version our APIs. This is where we use data transfer objects. A data transfer object or DTO is a simple Java object used to transfer data between different layers of an application. So imagine this is our application. At the heart of our application, we have our entities. These entities are part of the domain layer of our application. At the boundary of our application, which is where we have our APIs, we'll have our DTO's. These DTOs will be the input and output from our application. So going forward, we're going to introduce a bunch of DTOs and then we'll need to find a way to map DTOS to our entities. Let's see this in action. So back to our project, let's add a new package called DTOS. And in this package, let's add a new class user DTO. And note that I'm not capitalizing DTO. I'm using the Pascal naming convention. So we are capitalizing the first letter of each word. Even though DTL is an acronym, this is the same convention used in spring. For example, in spring we don't have JPA repository all in capital. We have JPA using Pascal naming convention. Okay. So this is our DTO. Now in this class, we add the fields we want to expose to the outside. So we're going to add long id as well as string name and string email. Not the password, not the profile, nothing else. Okay. Now we need to give this a constructor. So we can use all arcs constructor. We also need a getter so spring can read the data from these fields and create JSON objects with this. Now we go back to our user controller. Instead of returning user entities, we should return user details. Let's import it. Now we need to map user entities to user details. To do that, first we have to go to our repository. So let's go to user repository and change the base type from crowd repository to JPA repository. With this change, the find all method returns a list. So previously if you remember find all was returning an iterable but once we use a JPA repository find all returns a list. Now that we have a list we can use the stream API to map user objects to user details. Now if you're not familiar with stream API and mapping objects I covered this concept in the third part of my Java series. So here we call math and provide a function a lambda that takes a user and returns a new user dtol. Now here we should provide the arguments. So user get id, user.get name and user.get email. Okay. Now map returns a stream object. So finally we need to convert it to a list. Okay. Now we need to make the same change in the other method. So first we change the return type to user DTO and then over here first we create a user DTO and then we put it in our response user DTO. Okay, now let's restart our application. Back to Postman. Let's get all our users. There you go. Now we only have ID, name and email in the response, not the password or the address or any other fields. So this is the output from our API and we should try to keep it as stable as possible. If we change our domain model meaning our user entity, we just have to update our mapping code to make sure that the output from our API is stable. [Music] In the previous lesson, we manually mapped a user to a user DTO. While this works, it can become repetitive, especially when dealing with large DTOs with many fields. This is where we use mapping libraries. There are many mapping libraries out there, but the two most popular ones are model mapper and map. Model mapper uses reflection, that's why it's slower and harder to debug. On the other hand, map generates mapping code at compile time. That's why it's blazing fast, type- safe, and free of runtime overhead. So, in this course, we're going to use mapruck for mapping objects. Back to our project. First, let's go to our palm file. Now, we're going to add a new dependency. So, we press command and N on Mac or control and N on Windows to bring up the generate context menu. We select dependency. Here we start with the organization name that is or do mapapstruct. Now there are two libraries we need to add. One is map. The other is mapstruck-processor. First we're going to add mapstruck. Now make sure to use the same version so there are no surprises when you're following the course. Now let's add one more dependency org.mapststruct. This time we're going to add map processor. Okay. Now let's reload Maven. Good. Now back to our project. Here we're going to add a new package mappers. In this package we add a new interface. Let's call this user mapper and change the type to interface. First we should annotate this with the mapper interface defined in org.mapstruct and also as an argument we have to pass component model we should set it to spring so spring can create beans of this type at runtime. Now in this interface we can declare all kinds of mapping methods. For example we can add a method for mapping a user to a user DTO. So a method that returns user DTO and we call it to DTO and pass user. Okay, the name doesn't matter. What matters is the source and target type. With this interface in place, now we can go back to our user controller and modify our mapping code. So first we add a field of type user mapper and then in this method instead of manually mapping a user to user DTO we get a user and call user mapper to DTO and then we pass the user. Now when writing lambda functions whenever we have a lambda function that takes an object and then passes that object to a function we can use a shorthand syntax. If you press alt and enter here intelligj suggests to replace lambda with a method reference. There you go. This is much more concise and cleaner than what we had before. So we map objects and to do that we use user mapper to DTO. We should also update the mapping code in the other method. There is no need to create a user DTO here. We can simply call user mapper 2DTO and pass the user object. Now you might be wondering but what about the actual mapping code? All we have done so far is created an interface. This is the great thing about mapruck. When we compile our application, map will automatically implement this interface for us. Let me show you. So let's restart our application. All right. Now back to our project. Look here we have the target directory. Let's look at generated sources under annotations. Look, we have this class user mapper implementation. This is where we have the actual mapping code. So here's our 2D method. First we check if user is null we return null otherwise we create a user DTO with these values. So this code is autogenerated that means you should never touch it anytime you modify your source and target objects and recompile your application. Mapstro will automatically regenerate the mapping code. Now back to Postman. Let's hit our endpoint and make sure there are no errors. There you go. We get the same result as before. [Music] Sometimes we need more control over how Java objects are converted to JSON. This process is called serialization. Meaning converting a Java object into a JSON representation. Now, similarly, converting JSON back into a Java object is called des serialization. Now there are situations where we need to control how Java objects are serialized into JSON. We have a few annotations for that. We have JSON ignore for excluding fields. JSON property for renaming them. JSON include for excluding null or empty fields and JSON format for formatting values particularly dates, times, and numbers. Let's see these in action. So back to our user DTO. Let's say we want to exclude the ID field from our JSON objects. One way is to remove this field. But let's say we have some other code that is dependent on the ID field. So we cannot remove it from this class. In those situations, we can apply JSON ignore to exclude a field from our JSON object. Now let's restart our application. Now let's hit the user's endpoint. All right, look the ID field is gone. Okay, back to our code. So that was JSON ignore. We also have JSON property for renaming a field. Let's provide a different name like user underline ID. Now let's restart our application and hit the user's endpoint again. There you go. Look, ID is changed to user underline ID. Now sometimes we want to exclude null or empty fields from our JSON objects. For example, let's add another field here. Private string phone number. Now our users currently don't have a phone number. So if we restart our application and hit the users endpoint, phone number is null. Now what if we want to exclude null values from our JSON objects? That's very easy. Back to our DTO here. We apply JSON include and as an argument we supply the condition for including this field. Now Intelligj is suggesting the code. Let's press tab. So JSON include.incclude is an enumeration. In this enumeration, we have a bunch of values. The default is always. We also have non-MPT and non-null. Let's add null here and restart the application. Now let's hit the user's endpoint. Look, phone number is gone. Beautiful. Now the last annotation we're going to look at is JSON format for formatting data. So let me remove this new field. We don't need it anymore. Instead, we're going to add a new field of type local datetime called created at. Now, to give this some value, we have to go to our mapper. So, let's go to user mapper interface. Now, here we have to apply a special annotation for customizing the mapping code and that is mapping. Let's press tab to complete the code and import the mapping annotation. Now target we should change this to create at now we don't want to ignore this instead we want to provide a value to do that we set the expression attribute to a valid Java expression let's press tab to complete the code so we set this attribute to a string and here we start with Java followed by parenthesis inside parenthesis we type a valid Java expression so here we are passing java time. Datetime do now. Okay. Now let's restart the application and hit the users endpoint. All right. Look, now each user object has a created at property. Now look at the value of this property. We have the date component followed by a t to represent the time and here's the time component. Now this is the standard ISO format. It's not very human readable. And this is where we can use the JSON format annotation for formatting this date time. So back to our DTO, we apply JSON format and press tab to complete the code. So with this pattern, we can provide a date in this format followed by the time in this format. And of course, we can always change this to fit our requirements. Now let's restart the application and hit the user's endpoint one more time. All right, look. Created ad is now reformatted. Beautiful. Now, we don't need this going forward. So, let me remove this. And also back to our mapper interface. Let's remove the mapping [Music] annotation. All right. Now, let's see how we can extract query parameters from our requests. Query parameters are key value pairs that are added to a URL and we often use them for filtering, sorting, pageionation essentially as a way to provide input to our APIs. Now here in Postman we have the params tab where we can add our query parameters. Let's add a parameter called sort and set it to name. And one more page we set it to one. Now, as you can see up here, query parameters are added after question mark and they are separated using an amperand. Now, we don't need page in this lesson. So, let's simplify things and remove this parameter. There you go. Okay. So, we have the sort parameter. Let's see how we can capture it in our API. So, back to our user controller. Here is the get all users method. First, we should give this a parameter of type string called sort. Now, the type of the parameter doesn't have to be a string. In this case, I'm using string because we are capturing the name of a field. But if you were capturing a page number, we could use byte, int, long, any kind of numeric types. Okay. Now, if the value that is provided is not convertible to the target type, we'll get a runtime exception. Okay. So, let's change this back to string. Next, we should annotate this with request param. Now, how can we sort data? Well, we talked about this in the first part of the course. Find all has an overload that takes a sort object. If we press command and P on Mac or control P on Windows, we can see all the overloads. Here is an overload that takes a sort object. We also have another that takes a pageable object. And these are only available in repositories that extend JPA repository. So let's quickly check. Let's go to user repository. This interface extends JPA repository. And this is the interface that provides sorting and pageionation. Now back to our controller. So as an argument here, we call sort. First we import it. Sort by. Now by has a few overloads. We're going to use the first one that takes one or more string objects. So we can pass our sort argument to sort the data. We can optionally call ascending or descending. We don't really need it here. So let's restart our application and hit this endpoint with sort set to name. All right, our data is sorted by name. But to verify it, we go to the console window. Look at the first query sent to our database. We are selecting all these columns from the users table and we're ordering by name. Beautiful. Now what if we provide an invalid field like name X? We get a runtime error that translates to a 500 error in HTTP. Not the best experience for our clients. A better approach is to validate the sort parameter and if it's invalid, we can give it a default value. So back to our controller to do that there are various approaches. One simple way is to define a set of valid values. So we can call set first we import it set of we initialize it with name and email. Let's say these are the only valid values. Next we check if this contains the sort argument. If not then we can set sort to name by default. Let's restart the application and hit the endpoint. All right, no more errors. Beautiful. And if we check the console, here's our first query. In this query, we are ordering users by name. Perfect. Now, by default, the sort parameter is required. So, if we don't provide it, we get a bad request. We can make it optional by setting the required attribute of request param to false. Now let's restart the application again and hit this endpoint. All right. Now once again we got a runtime exception. Let's look at the console window. So we got a null pointer exception. Cannot invoke object equals because O is null. Where is this happening? This is happening in our user controller. Let's click here. This is essentially happening on this line where we are validating the sort parameter. We cannot pass null to the contains method. To fix this issue, we can give this a default value. So here we have an attribute default value. We can set it to an empty string. We could also set it to one of our valid fields like name. But I don't want to do this because if in the future we decide to change the name of this field to something else, there are two places where we have to update. So I would prefer to stick with an empty string with this. This will be an invalid value. So we'll set it to name by default. Let's restart the application and hit the end point. Okay, now our users are sorted by name. Now what if you provide sort but don't set it to a value? Our application still works. What if we set it to email? Now data is sorted by email. To verify that, let's look at the console. Well, there are so many queries here. So, let me clear this and hit this endpoint one more time. All right, take a look. Now, we are sorting users by email. Now, in case you're wondering what are these two additional queries, this is because of the eager loading, because of the relationship we have between user and profile objects. Technically, we don't need this relationship because the user entity essentially represents a user account. When working with user accounts, we don't really care about profiles. Profiles are additional information we have about our users. They have nothing to do with authentication, authorization, and so on. So, if you want to get rid of these queries, we can go to our user entity and remove the profile relationship. It's down here. We have a onetoone relationship and that's why we have eager loading by default and in hibernate if you fetch multiple objects like multiple users and we have eager loading to another entity by default hibernate sends multiple queries to the database instead of doing a join you can always optimize this using entity graph we talked about this before but anyway it doesn't really matter in this lesson so let's remove this field restart our application and hit the user's endpoint one more time Okay, now look in the console window. We have a single query for fetching the users. Now let me show you a problem with this implementation. Let's say tomorrow we decide to rename this parameter to something else like sort by. We can press shift and F6 to rename this. Let's change it to sort by. Restart the application and hit the end point. Now look in the console window. Our users are sorted by name even though we have set sort to email. The reason is obvious because we renamed this parameter. So this is no longer associated with the sort parameter here. So as a best practice whenever you try to work with a query parameter always set the name attribute we set this to sort. So if in the future we decide to rename the parameter name, our code doesn't break. Let's restart the application and hit this endpoint. Now back to the console. This time our users are sorted by [Music] email. All right. Now it's time for you to practice what you have learned. So in this exercise, I want you to build two API endpoints for fetching product data. First, create an endpoint that returns a list of products. This endpoint can optionally receive a query parameter called category ID for filtering products by category. If not provided, it should return all products. Now the response should be a list of product details with these fields. ID, name, description, price, and category ID. So in this DTO we don't have a full category object. We only have category ID. Now to implement mapping between product entity and product DTO you have to add a custom annotation to your mapping method. So here we have set source to category ID which means we get the value from the source object. We go and grab category do ID and use that to set the category ID field of the target object which is product DTL. Okay, next we should build an endpoint for fetching a single product by ID. If the product exists, return a product DTO. Otherwise, return a 404 not found error. Now, I've put this PDF below this video, so you can always come back to it. Spend about 20 to 30 minutes on this exercise and then come back and see my solution. All right, I'm going to go a bit faster because I'm assuming you have worked on this exercise and just want to quickly watch how I would implement these two end points. So, I'm going to go in the controllers package and add a new class product controller. Next, we annotate this with rest controller and expose it at the products endpoint. Next, we define a method that returns a list of product DTO. We haven't created this class yet, but we can create it right here. We press alt and enter and create this class. Now, we don't want to put this in the controllers package. We want to put it in the DTO's package. Next, we add our fields. Private long ID, private string name, price. We change the type to big decimal. Then we add description as well as category ID. Okay. Now we annotate this with data instead of getter and setter. Back to our controller. We import list and call this method get all or get all products. Here we should call product repository. If you press enter, Intelligj adds this as a field in this class. and initializes it using this constructor. But we can simplify this code by removing the constructor and applying the all args constructor annotation. Now before implementing filtering, I just want to fetch all products and build a simple endpoint. So I want to do this in baby steps. So here we call find all. Next, we should map products to product DTO's. For that we have to create a mapper. So back to our project we go to the mappers package and add a new interface called product mapper. We annotate this with the mapper annotation and then add a method that returns a product detail. Product DTO DTO and we give it a product object. Let's import product. Good. Now we should customize mapping. So we apply mapping annotation. That's a target as well as source attributes. So we go in the source object which is a product entity and map category ID to the category ID field of the target object which is product DTO. Now back to our controller, we add our mapper to this class. So private final product mapper. Now we call find all. Then we use the stream API and map each product to a product detail. This returns a stream. So we convert it to a list and then return the result. Finally, we expose this using the get mapping annotation. Let's restart our application and test it up to this point. So back to Postman. Let's hit our products endpoint. Okay, here's our product. You can see that mapping is done properly. So we have category ID one, one and two. Beautiful. Now let's implement filtering. So back to our controller, we give this method a parameter of type bite category ID and annotate it with request pro. As a best practice, we give it an explicit name and then we make it optional. Now here depending on if you have a category or not, you have to call two different methods of our repository. First we have to go to our repository and add a method for filtering products by category. So we return a list of product. Let's import this and call this method find by category ID. Then we pass category ID. Now back to our controller. Here we declare a list of product call it products. Then we check if we do have a category we call product repository.find by category ID. Otherwise, we set products to product repository final. Now that we have a list of products, we can simply convert all of them to product DTOS. Let's restart our application. Let's hit the endpoint without any query parameters. Okay, we get all products. Lovely. What if we set category ID to an empty string? We still get all products. Great. What if you pass one as the category ID? We only see products in this category. Okay. Now, what if we pass an invalid category? We get an empty list. And that's totally fine because we don't really have a product in this category. Now, we could alternatively return a 404 error, but I think that's a little bit too much. There's really no need to do that. That makes our API a little bit angry. So, we're done with this now. Look at the console. There are a bunch of queries here. It's not quite clear what's happening. So, I'm going to clear this window and hit this endpoint one more time. All right, look. We have this query for fetching products and categories from our database. Now, what if we don't provide a category ID here? Now, we get three extra queries. Let me show you one more time. So I'm going to clear this window and hit the endpoint without a category. In this scenario, we get three queries. The first one is for fetching products. So we are fetching all these columns from the products table. And then we have two extra queries for fetching the category for each product. So in this scenario, there is no join between the products and categories tables. This is how hibernate works by default. So if you have eager loading between two entities and we retrieve a list of entities, hibernate will send additional queries for fetching the related entities. Now this is not the n plus1 problem because all these queries are sent in one session. But we can still optimize this by using a join to fetch all the products and their categories. To do that we have to go to our repository and create a new custom query method. So this method should return a list of product. We can call it find all with category to specify that we're including categories with this query. Now because this is a custom query and doesn't follow the conventions in Spring Data JPA, we have to annotate this with the query annotation, we can write a JPQL query like this. So we select P from product P and do a join with P.Cate. Alternatively, we could remove the join part and use the entity graph annotation and set attribute paths to category. Both give you the same result. Now let's go back to our controller and replace find all with find all with category. Let's restart the application and clear this window. Now let's hit this endpoint. Look at the console. We have a single query for fetching the products and the categories. And here's our left join. Okay, so we are done with our first endpoint. Now, one more time, let's verify what happens if we pass a category ID here. All right, looks like earlier I made a mistake. In this scenario, we're also getting multiple queries. So, we can optimize this using the entity graph annotation. So we go to our repository and apply the entity graph annotation on this other query method. Let's restart the application. Okay. And hit this endpoint. All right. Now we have a single query to fetch the products and categories. So we're done with the first endpoint. The second endpoint is pretty straightforward. It's exactly like the code we wrote for fetching a single user. So I'm not going to waste your time typing all that code by hand. If you want to compare your code with mine, we have a commit for each lesson in this repository. So, we're done with this exercise. Let's move on to the next [Music] lesson. You learn how to provide additional data in requests using query parameters. As I told you, these query parameters are often used for filtering, sorting, and pageionation. But we have another way for providing additional data in our requests and that is using request headers. These headers just like query parameters are key value pairs. Here are the seven headers that are sent by Postman by default. If you don't see these, we can toggle them up here. So these are the default headers sent by Postman. Your browser will probably send some additional headers to the back end. Now these headers are often used for metadata. They're often used for authentication, caching, and so on. So, as an example, let's add a custom header here for passing an authentication token. So, by convention, we prefix custom headers with XY. Let's call this O token and set it to 1 2 3 4. Now, to capture this, we go back to our controller. Here is get all users method. We add a new parameter here. string o token we prefix it with request header. So just like request pram we have request header. Now we give this a name that is x - oy- token. Now we have a little warning here. Intelligj is saying unknown http header. We can click this link or press alt and enter to add this custom http header. The warning is gone. Now for simplicity let's just print O token on the terminal. So south tab O token. Let's restart the application and hit the end point. All right. Now take a look in the console. So we have 1 2 3 4. Beautiful. Now this header is not case sensitive. So if we set this to token in capital look in the terminal our application is still working. But by default this is required. So if we remove this from our request and hit this endpoint we get a bad request. Meaning we didn't provide the necessary data for calling our endpoint. But we can easily make this optional just like request pram. We have the required attribute here. If we set this to false and restart our application and then hit this endpoint our application works. Beautiful. So this is how we can extract request headers. At this point, we don't need them. So to clean up our code, I'm going to remove this parameter and the print statement. So far we have covered a couple of ways for providing data with our requests. We can use query parameters for providing simple values often used in sorting, filtering, and pageionation. We can use request headers for providing metadata like authentication tokens, caching and so on. But there is a third way and that is using request body. With this we can send the actual data or content to our back end. This is often used for creating or updating objects. So let's see how we can use this to send the user object to our back end. Now for creating objects, we cannot use the get method. This is only used for getting data. So we should change this to post. Now we don't need the query parameter here. So we send a post request to the user's endpoint. Now here on the body tab let's change the type to raw. Now in this dropown list we can provide the type of data we want to send to the server. We can send text like a string. We can send JavaScript code, JSON objects, HTML and so on. Most of the time we use JSON. Now in this box we provide a valid JSON object. So we add curly braces and one or more key value pairs. Our keys should be surrounded with double quotes. So let's send a user object with the name set to mosh or whatever you want and email set to mosh atcodewithmsh.com. Now if we send this to our back end we get an error with the status of 405 which means method not allowed because we haven't implemented an endpoint that receives post requests. So back to our user controller let's add a method public for now let's just return a user DTO object but the return type can be anything. Let's call this create user and give it a parameter of type user detail and we can call this data. Now to receive the request body, we should annotate this with request body. This is a common source of errors. Make sure to include it. Otherwise, you're going to get null values on your back end. Okay. Now, because we're using the post method, we should annotate this with post mapping. For now, let's just return data to the client. So, whatever we send to this endpoint, we'll get it in the response. Now, let's restart the application and send this request again. All right, look what we get. ID set to null because we didn't provide it up here. We only have name and email. Now, if we use an invalid property like email X, again, Spring is not able to initialize the email field. That's why we get no. Now, as a refresher, this process, the process of converting a JSON object to a Java object is called des serialization. And the other process which is converting a Java object back to a JSON object is called serialization. Okay. So, this is how we can send data using request body. In the next lesson, I'm going to show you how we can actually create a user object. [Music] Now let's see how we can create objects or resources in restful terms. So we're going to send a post request to the user's endpoint. And in the body of the request, we're going to include a valid user object. So we should include the name, the email, and the password. Back to our controller. Now we have a problem. In this method, we are receiving a user DTO object in this class. We don't have the password field. We had it earlier, but we had to remove it because our passwords were leaking outside of our APIs. Now, you might be wondering if we can add the password field here, private string password, and annotate it with JSON ignore. This is not going to solve our problem because this annotation is applied both during serialization and des serialization. So that means if you have this annotation here, spring will not read the password property of our JSON objects and put it into this DTO. Okay, so this is not going to solve our problem. Earlier we talked about the architecture of our application. I told you that our entities are at the heart of our application and API models or DTO's are at the boundary. With this separation, we allow the DTO's and entities to evolve independently. Here is another example where we need a separate DTO for creating new users. In that DTO, we're going to have the password field and also we are not going to have the ID field. This is not needed when creating a new user object. Right? So back to our project here in the DTOS package, let's add a new class. We can call this register user DTO. Alternatively, we can replace DTO with request. That's another convention a lot of people follow. This better aligns with the request response model of HTTP. So this class essentially encapsulates all the data we need for sending a request to register a new user. What fields do we need? We need the name, the email and the password and not the ID field. Right now we should annotate this with getter and setter. So spring can initialize these fields using the request data. Alternatively, we can apply the data annotation which is the combination of getter setter to string and two hash code. It makes our code a little bit cleaner. Now up here let's remove the unused import statements. Good. So we have three fields. Now we need to provide the mapping between our new DTO and user entity. And for that we go to our user mapper interface. Here we add a new method that returns a user object. We can call that to entity and give it a register user request object. Okay. Now let's go back to our controller and change the type of the parameter to register user request. And for consistency I would prefer to rename the parameter to request as well. Now at this point we don't want to return the same request. So let's return null. We'll come back to this momentarily. First let's map this request to a user entity. Print that entity on the terminal and make sure everything works up to this point before going further. So always do one baby step at a time. So here we call mapper dot to entity and provide the request object. We get a user and then print it on the terminal. Now let's go to our user class and see if we have the two string annotation. We don't have it here. So let's add it temporarily. Now Intelligj is suggesting to exclude lazy loaded fields. This is for performance reasons. We talked about this in the first part of the course. Let's just go ahead with the suggestion. Again, this is just a temporary solution. We just want to inspect the user object in the terminal before saving it to the database. So, let's restart the application and send this request. All right. Obviously, we don't see anything in the response. The status is 200, which means no error happened. Now, here in the terminal, we have this user object. ID is null obviously because we haven't provided it. But we have the name and email fields. Where is password? Well, I just realized that in part one of the course, we implemented the tworing method in this class. So, it's right here. We didn't have to apply the two string annotation. In this implementation, we are not including the password. Again, as a temporary solution, I just want to add the password here. So, let's set password to password. And before we forget, let's remove the two string annotation on the top. Not needed. Let's restart the application and send this request. Okay. Now look in the terminal. All right. Here's the password. So our mapping is working properly. Now before going forward, I want to undo the changes we made to the user class. So we go to the commit window, select the user class and roll back the changes. Okay. Now back to our controller. Once we have a user, we can save it using our repository. So user repository save user. The database will assign the ID to this user. Next, we should map that to a user detail and return it from this method. So we can create a user detail by calling usermapper dot dodtol and then return it at the end. Now intellig is suggesting that this local variable is redundant. We can combine these two lines. That's absolutely right. But don't do this yet. We're going to come back to this momentarily. Let's restart the application and make sure that we can successfully save the user to the database. So send. All right. Here's a new user with the ID of three. Currently, our database doesn't have a unique constraint on the email. So, we can register multiple users with the same email. That's not the right way to do it. We'll come back and fix this in the future. But what I want to point out is that every time we send this request, we get a new user with a different ID. Beautiful. Now, there is one more piece that we have to implement before we finish this. When creating resources in REST APIs, we should set the status to 2011, which means created. To do that, we have to change the return type of this method to response entity and then at the end we call response entity.created. Now look at the parameter of this method. It requires a URI. This is the location of the new object or the new resource that is created. So if you have a user with the ID of five, that's going to be users /5. Now, how can we generate that URL? Well, back to this method. Let me put this on a new line so you can see clearly. We're going to give this a second parameter of type URI components builder. Components builder. Now, let's simplify the name of the parameter. Let's change it to URI builder. That's better. Now once we map this user to a DTL we can call URI builder path provide the path to our resource. So / users/ id as a parameter and then we call build and expand and provide the id of the new user as an argument. And finally we call dot to uri. Let's press tab. This returns a URI object. We can store it here. And then at the end we call response entity created. We pass the URI. Now this method returns a bodybuilder. Funny name. It's not a response entity. To convert this to a response entity we call dot body and provide our user detail in the body of the response. User detail. Okay. Now let's restart the application and see what happens. So let's create one more user. All right. This time we got the status of 2011. Now look in the headers tab. So HTTP responses just like requests also have headers. Here we have a header that is location. It's a standard HTTP header. And this is set to the URL of the new resource or new user. Now quite frankly a lot of people don't implement this step. They don't set the status to 2011. So here we could get away with generating the URI and simply return the user DTO. That's totally fine for internal APIs, but if you're building an API for public to use, it's best to follow standard REST [Music] conventions. All right, now let's talk about updating resources. To update a resource, first we should change our request method to either put or patch. What is the difference? We use put for replacing an entire resource and patch for patching or updating one or more properties. Quite often we use put. So let's change it to put. Now when updating a resource, we should reference a particular resource. So like the user with the ID of one. Now just like creating resources here in the body of the request we should include some data to send to the server. Now when updating users we don't want to include the password because the process of updating a user's password is often different from updating basic account information. When updating a user's password for security reasons we should provide both the old and the new password. We don't want to add two password fields here like old password and new password because the user may only want to update their name and email, not the password. So, we want to handle these two scenarios separately. In this lesson, we're only going to focus on updating basic account information. So, let's remove the password property. Now, back to our controller, let's add a new method, public. For now, let's just return a user DTO and call this update user. Now, here we shall annotate this with put mapping and provide the ID parameter. Now, because our route or endpoint has a parameter here, we should add a parameter of type long id and annotate it with path variable. Now, as a best practice, we should also give it an explicit name. So if tomorrow we decide to rename this parameter to something else like user ID, our code will not break. Now here we should also add another parameter for reading the request body. So let me put this on a new line so we can see clearly. Now here we have two options. One option is to use user detail. Let's see if that makes sense. The user detail has ID, name, and email. It's possible to use this DTO for updating users. Even though we don't need to provide the ID in the request body, but I'm a bit reluctant to use this DTO because in the future we might add additional fields here that may not quite apply to the process of updating user accounts. So it's better to create a separate DTO for updating users. So here in this package, let's add a new Java class update user request. Now what fields do we need here at this moment? Only name and email. So tab and tab. Let's annotate this with data. Beautiful. Now back to our controller. Let's change the type of this parameter to update user request and also make sure to annotate it with request body otherwise it's not going to work. Now when updating resources first we have to do some validation and make sure that that resource exists. If not we should return a 404 error. So here we can simply press tab to add all this code. We are using the user repository to find the user with this ID. If not found we return null and at this point we should return a 404 error to the client. So let's change the return type of this method to response entity of userdl. And here we call response entity do not found build. Otherwise if you have this user in our database we should update it with the data in our request. One way is to do manual mapping like this. But I don't want to do this because this is only suitable for small objects. So let's go to our user mapper interface and add a method for updating an existing user with a DTO. In this method, we don't need to return any objects because we are not creating a new object. We can call this update or whatever we want. We should give it two parameters. Update user request and user. Now here we should also annotate this target entity with mapping target. If you don't apply this, you're going to get a compile time error. Now with this method in place, we can go back to our controller. And once we have a user object, we can call user mapper update. We provide our request and user entity. Next, we call user repository.save. And finally, we map this user to a user DTO and return it in a response. Pretty straightforward. Now, let's run the application. Now, let's look at our database. So here's our users table. Here's our first user. I'm going to change the name and email of this user to mosh with mosh at code with mosh. Okay. So we're sending a put request to user one. And here's our data. Beautiful. Send. Okay. We got a 200 response. And here in the body of the response, you can see the updated user object. Now if you go back to our database and refresh the data, you can see that the first user is successfully updated. Now to test our error handling logic, let's update a user that doesn't exist, like the user with the ID of 100. Okay, we get a standard 404 error. Beautiful. Next, we're going to talk about deleting [Music] resources. Deleting a resource is pretty straightforward. First we should change the request method to delete. Now just like updating a resource we should reference a particular resource like the user with ID one. But unlike the update scenario we don't need to include any data in the body of the request. So we can delete all this data. Now back to our controller let's add a new method public. For now I'm going to use void as the return type but we'll come back and change this in a second. So void delete user. we should give it a pass variable and of course a delete mapping to capture the ID. Now in this method just like the update method first we should get the user from our repository and if it doesn't exist we should return a 404 error. So let's change the return type to response entity. Now we don't want to return any data to the client. So we can pass void here. Now to save time, I'm going to borrow some code from the update method. So the first three lines where we fetch a user and return a not found error. So copy paste it here. Otherwise, if we do have a user, we call user repository delete user. And finally, we return response entity nocontent.build. Let's restart our application and delete the user with the ID of one. Okay, we got a 204 response. No content. Now, let's look at our users table. Our first user is gone. Beautiful. Now, what if we try to delete a user that doesn't exist? we get a 404 [Music] error. In restful APIs, we typically use put or patch for updating resources, but some updates represent an action rather than just modifying a field. Examples are changing a user's password or submitting an approval request. In these cases, it's better to use a post request instead of put or patch. Because we're not just updating a resource, we're creating a request to perform an action. Now, let's see how we can take this concept and use it to implement an endpoint for changing a user's password. So, we're going to send a post request to a new endpoint like this users one/change password. So we are creating a new change password request. Okay, we're not updating a field. We're creating a request to perform an action. Now when hitting this endpoint in the body of the request, we should provide the old and the new password. So let's set old password to 1 2 3 4 and new password to let's say 5 6 7 8. Now back to our project here in the details package. Let's add a new class change password request. We annotate this with a data annotation and give it two fields old and new password. Next, we go to our user controller and define a new method for updating the password. So, public. Now for the return type, we're going to use response entity of void because we're not going to return any data in the response. We can call this change password. Next, we should annotate this with post mapping. So we provide the ID parameter and then add change password. Now because we have the ID parameter, we should add a parameter of type long here and annotate it with pass variable. We also need a parameter for reading the request body. So let me put this on a new line. And then we add the second parameter that is change password request and we should annotate it with request body. Okay. Now in this method first we should fetch the user with our repository and if we can't find it we should return a 404 error. So I'm going to borrow this piece of code from our delete method. Paste it here. Simple. Next, we should validate the old password. So we check if user get password that equals request get old password. Well, we have to inverse this condition to not equal. In this case here, we have two options. Intelligent is suggesting to return a bat request or a 400 error. But I think a more appropriate status here is unauthorized because if a client doesn't provide the correct old password, it's not authorized to perform this action. Now in this class, we don't have a factory method for setting the status to unauthorized. So we have to new up a response entity and here we use HTTP status dot unauthorized. Otherwise, if the password is correct, we should update it. Now, I'm going to go ahead with intellig suggestion. So, let's add these three lines. We simply update the user's password using the new password. And for this, we can use this single line. We don't need to update our mapper. We should use our mapper only when we are dealing with mapping large or complex objects. Then, we save the user. And finally, we return a response with no content. Now, let's restart our application. and test our new endpoint. First, I want to test a scenario where the user doesn't exist. So, user 100. We get a 404 error. Beautiful. Now, let's try user two. Now, currently in my database, the password of this user is 1 2 3 1 2 3. So, obviously the old password is incorrect. Let's send this request. We get a 401 or unauthorized response. Beautiful. Now what if we provide the correct password? We get a 204 response. No error but no content. Now if you refresh our database, we can see that the password is updated. Now currently we're storing the passwords as plain text. Obviously this is something you should avoid at all cost. But later when we talk about security, we'll come back and fix this issue. [Music] Okay, for your next exercise, I want you to implement create, update, and delete operations for products. First, implement an endpoint for creating a new product. At this endpoint, we should receive a product DTO with these fields. This is the same product DTO we created earlier in the section. So in this case we are not going to create a separate DTO for creating and updating products because in many cases the fields we need for creating or updating a resource are the same. So we don't always have to create separate DTO's for creating and updating resources. Okay. So we send a product DTO to this endpoint and then we get a 2011 response with the created product. Now updating and deleting the product is pretty straightforward. Go through this PDF. I put the link below this video. Spend about 20 to 30 minutes on this exercise and then come back and see my solution. All right. So here in product controller, we define a new method that returns a response entity of product detail. We call it create product and give it a product DTO object. Now make sure you have annotated this with request body otherwise you will not receive the data posted to the server. Now we annotate this with post mapping. Now in this method first we should map this DTO to a product entity. So we go to our product mapper interface and define a new method that returns a product object. So we call it two entity and give it a product DTO. Now back to our controller. First we call product mapper dot to entity. We pass the detail and get a new product. Next, we call product repository that save product. Now, before implementing the full picture, I just want to return this new product. So, at this point, I don't want to set the status to 2011. We want to implement this with baby steps. So, we call response entity. Now, there is no need to map this product to a new DTO because this DTO that we have up here has all the data that we need to send back to the client. The only thing that is missing is the ID. So after we save the product, we call product DTO set ID. And then we can simply return the same DTO back to the client. Let's restart our application back to Postman. Let's send a post request to the products endpoint. In the body of the request, I'm going to include this JSON object. We have name, price, description, and category ID. Let's send this. All right, here's what we get. Our new product ID is 13. Beautiful. We have name, price, description, and category ID. Let's verify that this object is also stored in the database. So, we go to the database window and open the products table. Here's our new product. But look, category ID is missing because in our controller once we map this DTO to an entity, we lose category ID. In this DTO, we have a field called category ID. But there is no field with the same name in this entity. So to solve this issue, we have to fetch the category separately from the database. So first we call category repository. Now, Intelligj should add this as a field in this class. There you go. So, we call category repository that find by ID and here we pass product DTO that get category ID or else null. So, we retrieve the category. Now, we have to do a bit of validation. So, if category is null, then we want to return a bad request to the client. I didn't specify this in the PDF, so that's totally fine if you missed this step because in this section, our focus is not on error handling and data validation. We'll talk about that in the next section. Anyway, we get the category. Now, before saving the product, we should set the category. So, we call product set category and pass the category. Now, let's restart the application and hit this endpoint one more time. Okay, back to the database. Here's our new product and category ID is successfully stored here. Now, to verify our error handling code, let's pass an invalid category ID. In this case, we get a 400 response. Beautiful. We're almost done with this method. The final step is returning a 2011 response with the URI of the new resource. To do that we have to add a second parameter here of type URI components builder. After we save the product we need to create this URI. So we call URI builder provide the path then call build and expand and finally call to URI. We get a URI object then we call response entity.created. We provide the URI and the detail in the body of the response. Let's restart and hit this endpoint one more time. We have a 2011 response and in the headers we have the location of the new resource. Beautiful. We're done with the create operation. Now let's implement the update operation. Back to our controller, we add a new method that returns a response entity of product DTO. We call it update product. Now, Intelligia is suggesting a big chunk of code. Let's just add all of that in one go. So, here we have two parameters long ID which is decorated with pass variable. That means we should also annotate this method with put mapping. We also have product DTO in the body of the request. So, first we fetch the product from our database. If it doesn't exist, we return a not found error. Otherwise, we should map this DTO to a product entity. More accurately, we should copy these values into our existing product entity. So, we go to our product mapper and add a new method void update with two parameters product detail and product. Now, we should annotate this with mapping target otherwise mapping is not going to work. Now, back to our controller. Once we have a product, we call product mapper update and pass these two objects. Next, we save the product and finally we return our DTO to the client. So, product DTO. Again, there is no need to map our product entity back to a DTO. This DTO that we receive in this method has all the data we need. Okay, let's restart the application. Now here in Postman, let's send a put request to products /1. I don't have this product in my database. So now we should get a 404 error. Take a look. There you go. Beautiful. Now let's send a put request to product 4. Okay, we got an internal server error. All right, we got a hibernate exception saying identifier of an instance of product was altered from null to four. What is happening? Well, this was the tricky part of this exercise. So when we call productmapper update, something goes wrong. This product detail doesn't have an ID because in this method we are receiving the ID as a path variable. Okay, so product D is here doesn't have an ID and when we copy ID to this product, the ID of this product changes from whatever we had which was four to null. That's why we get this exception. To fix this issue, we have to go to product mapper and when updating an existing product, we should tell mapr to ignore the ID field. To do that, we customize mapping. So we add the mapping annotation. Target should be ID. And here we set ignore to true. Now let's restart the application and send this request again. All right, we got a 200 response, but the ID that we have in the response is no. That's an easy fix. Back to our controller. I told you that our product detail doesn't have an ID. So after we save this product, we can store the ID in the product DTO just like we did in the create endpoint. So we set the ID and then return this DTO to the client. Let's restart the application and send this request again. Here's the ID. Now let's verify that we have the correct data in our database. So here's product 4. All the values seem to be updated correctly. Now let's change category ID and see what happens. So I'm going to change category ID to two and send this request again. Now let's refresh. Okay, category ID is not updated for the same reason it was not stored when we created a new product. So back to our controller, we have to fetch the category separately. So here we call category repository find by ID. We get this category, store it here, category. If it doesn't exist, we return a bad request. Otherwise, we fetch the product. We do the basic mapping. Then we associate our product with this category with the new category and then save it in the database. Let's restart the application and send this request one more time. Okay, no errors and we see category ID 2 in the response. Now back in the database, you can see that category ID is now updated. To verify it one more time, let's change it back to one and resend this request. Good. Now let's refresh this table. And here's the updated category. Beautiful. The final part is the delete operation. So we define a new method public response entity of void. Delete product. We give it a pass variable ID and annotated with delete mapping. In this method, first we use our repository to fetch this product. If it doesn't exist, we return a not found error. Otherwise, we delete this product from our repository and return a response with no content. Let's restart the application. Now, let's send a delete request to this endpoint. We got a 204 response with no content. If we resend this request, we get a 404 error because this product no longer exists. Hey guys, thanks for sticking with me so far. If you're enjoying this tutorial, I wanted to let you know that this is just the first hour of my complete Spring Boot course. The full course is 9 hours long and takes you way beyond the basics. We'll build the back end for an actual e-commerce application with authentication, role-based access control, shopping cart functionality, payment processing with Stripe, and full deployment to the cloud. So after you watch this tutorial, if you want to learn more and level up your skills, you can enroll in the full course using the link in the description. [Music]"
M5B-xBmznok,"Hey guys, many of you have been waiting for part two of my spring boot series and I just wanted to let you know that it's coming very soon. In this part, we'll build the back end for real e-commerce application complete with authentication, role-based access control, a shopping cart and checkout system, payment processing with Stripe, and full deployment to the cloud. You'll learn how to build secure productionready APIs, and more importantly, how to organize and structure your code like a professional developer. I've put my heart and soul into creating this course to make it the most practical and comprehensive Spring Boot course out there and to help you level up your skills and confidence as a back-end developer. Stay tuned. It's launching very soon."
Iqz7BWePOys,"hey everyone msh here a few days ago I published a spring boot tutorial on this channel and some of you asked what is spring Boot and why should I learn it great questions let's start with the spring framework because to really understand spring boot you need to know where it comes from Spring is one of the most popular Frameworks for building Java applications think of it like a toolbox it's got everything you need to build scalable Enterprise grade applications and it's modular which means you can pick and choose the modules you need these modules are broadly categorized into a few different layers at the core we have modules for handling dependency injection and managing objects I know it might sound confusing but trust me I've covered this in depth in my spring boot course it's not really that complicated in the web layer we have modules for building web applications with these modules we can handle HTTP requests process data and return responses whether it's HTML for a web page or Json for an API in the data layer we have modules for working with databases whether you're using SQL no SQL or even inmemory data basis we also have a module for adding cross cutting features like logging or security without cluttering the main code this is called aop or aspect oriented programming we also have spring test for testing of spring components so a spring is amazing but it comes with a catch it requires a lot of setup for example if you want to build a web application you might need to set up a web server configure routing and manage dependencies manually this can make development slower and more complex and that's exactly why spring boot was created spring boot is a layer on top of spring that removes all the painful setup think of it like this if spring is a toolbox spring boot is a preassembled workstation instead of spending hours setting things up you can just start coding right away it comes with sensible defaults Auto configuration and embedded servers so you can go from an idea to a working application in minutes that's why spring boot is one of the most widely used Java Frameworks in the industry major companies like Netflix Amazon and Google rely on it to build scalable applications and because of that spring boot developers get paid really well according to glass store Spring boot developers earn between 160,000 and $300,000 a year which is huge if you're a Java developer learning spring boot can open up better job opportunities and higher salaries so now that you know why spring boot is so valuable the next step is learning it properly I've just uploaded the first hour of my spring boot course for free on YouTube where I walk you through the fundamentals step by step I'll put the link for you in the description box"
v73-ps01c5w,"hey everyone msh here a few days ago I published a spring boot tutorial on this channel and some of you asked what is spring Boot and why should I learn it great questions in this short video I'll break it down for you what spring boot is why it exists and most importantly why learning it can be a GameChanger for your [Music] career let's start with a spring framework because to really understand spring boot you need to know where it comes from Spring is one of the most popular Frameworks for building Java applications think of it like a toolbox it's got everything you need to build scalable Enterprise grade applications and it's modular which means you can pick and choose the modules you need these modules are broadly categorized into a few different layers at the core we have modules for handling dependency injection and managing objects I know it might sound confusing but trust me I've covered this in depth in my spring boot course it's not really that complicated in the web layer we have modules for building web applications with these modules we can handle HTTP requests process data and return responses whether it's HTML for a web page or Json for an API in the data layer we have modules for working with databases whether you're using SQL no SQL or even inmemory databases we also have a module for adding cross cutting features like logging or security without cluttering the main code this is called aop or aspect oriented programming we also have spring test for testing of spring components by the way the spring framework is just one part of a larger family of projects in the spring ecosystem these projects extend the capabilities of the framework to address specific needs for example we have spring data for simplifying database access Spring Security for adding authentication and authorization to your applications spring batch for batch processing spring Clow for building microservices and distributed systems spring integration for simplifying messaging and integration between systems and more so a spring is amazing but it comes with a catch it requires a lot of setup for example if you want to build a web application you might need to set up a web server configure routing and manage dependencies manually this can make development slower and more complex and that's exactly why spring boot was created spring boot is a layer on top of spring that removes all the painful setup think of it like this if spring is a toolbox spring boot is a preassembled workstation instead of spending hours setting things up you can just start coding right away it comes with sensible defaults Auto configuration and embedded servers so you can go from an idea to a working application in minutes that's why spring boot is one of the most widely used Java Frameworks in the industry major companies like Netflix Amazon and Google rely on it to build scalable applications and because of that spring boot developers get paid really well according to glass store Spring boot developers earn between $60,000 and $300,000 a year which is huge if you're a Java developer learning spring boot can open up better job opportunities and higher salaries now I know someone in the comment is already typing msh why are you talking about job opportunities haven't you heard AI is taking over coding is dead yeah sure but you know go ahead and let chat GPT build your next production system let's see how that goes so now that you know why spring boot is so valuable the next step is learning it properly I've just uploaded the first hour of my spring boot course for free on YouTube where I walk you through the fundamentals step by step I've put the link for you in the description box and by the way if you're new here make sure to subscribe because I post coding tutorials all the time that's it for this one thanks for watching and I'll see you in the next video"
gJrjgg1KVL4,[Music] welcome to the ultimate spring boot course in this course you'll learn everything you need to know from the basics to more advanced concepts so by the end you'll be able to build real world applications with confidence if you're looking for a comprehensive easy to follow well structured and practical course that takes you from Zero to Hero this is the spring boot course for you I've organized this course in two parts the first part which you're watching now covers the fundamental concepts and the second part focuses on building web applications and apis the course is packed with Hands-On examples and real world exercises to help you truly absorb and apply what you learn I've poured my heart and soul into creating this course and I'm confident it will be a game Cher for your skills I'm m hamadani a software engineer with over 20 years of experience and I've taught Millions how to code and become professional software Engineers through my YouTube channel and online school codm mar.com if you're new here make sure to subscribe as I upload new videos all the time so if you're ready to master spring Boot and build applications with confidence let's jump in and get [Music] started to get the most out of this course you should have a solid understanding of java you should be comfortable with objectoriented programming working with classes methods and interfaces if you're new to Java or need a refresher I recommend going through my Java course before starting this one I'll put the link down below you should also be familiar with relational databases and SQL you should know Concepts like tables primary Keys foreign keys and writing basic queries if this sounds new to you or you want to strengthen your SQL skills check out my SQL course where I cover everything from the basics to more advanced queries that's all you need to get started if you already meet these prerequisites you're good to go otherwise take some time to review Java and SQL before jumping in now let's move on to the next [Music] lesson before we dive in let's talk about how I've structured this course so you know what to expect and how to get the most out of it this course is divided into two parts the first part which you're watching now covers the fundamentals of spring boot the second part will focus on building web applications and apis in the first part we'll go step by step to build a strong foundation so that when we move on to building applications you will have all the essential skills you need part one is divided into three sections we'll Begin by understanding what spring boot is and why it's such a powerful framework we'll also set up our development environment and build our first spring boot project so we can get a feel for how everything works then we have dependency injection in this section you will learn how spring boot manages objects and their dependencies behind the scenes making our applications more modular testable and maintain aable in the next section we talk about database integration with spring data jpa this is the bread and butter of part one we cover Concepts that are often overlooked in other courses you will learn best practices efficient data access patterns and tools that are essential for building real world applications to get the most out of this course watch every lesson in sequence I cover a lot of details that built on previous Concepts so skipping around might cause you to miss something important this course is also packed with exercises to reinforce what you learn I strongly encourage you to complete each exercise before watching my solution struggling a bit before seeing the answer will help you retain the concepts much better now that you know how the course is structured let's move on to the next [Music] lesson as you go through the course you'll often want to check out the exact code I write in each lesson so to make it easy for you to follow along I've organized the source code using a GitHub rep repository that you can find at github.com hamedani sspring store now technically you don't need to know git to take this course but git is one of those skills that every developer must have if you want to dive deep and truly Master git I have a complete git course on my website where I teach everything from the fundamentals to Advanced workflows you can find it on codewithc now back to our repository in this repository each commit represents a lesson so if you want to see the exact code I write in this lesson just click here and you can see the changes also I've created tags for the beginning of each section for example if you want to start from part one section 4 you can use this tag it's not something that I recommend unless you're an advanced student because there's so much that we're going to cover in this course and ideally you should watch every lesson in order so that's all about our git repository let's move on and continue learning learning welcome to the first section of the course in this section we'll take our first steps with spring boot we'll start by learning what spring boot is and why it's so popular among Java developers next we'll get our development environment set up and create our first spring wood project I'll walk you through the project structure so you understand how everything is organized from there we'll dive into dependency management then build and run our first spring wood application we'll also cover some essential tools like spring boot Dev tools that make development faster and easier you will learn how to configure your app with properties and how to debug it when things go wrong by the end of this section you'll be comfortable setting up and running spring boot projects and you will have your first application up and running now let's get [Music] started before we jump into writing code let's take a few minutes and talk about what spring framework is what it off offers and how spring boot Builds on it to make our lives easier let's start with the spring framework it's a popular framework for building Java applications think of it as a toolbox for building applications it has a lot of modules each designed to handle a specific task these modules are broadly categorized into a few different layers at the core we have modules for handling dependency injection and managing objects we'll talk about that in detail in the next section in the web layer we have modules for building web applications with these modules we can handle web requests process data and return responses whether it's HTML for a web page or Json for an API in the data layer we have modules for working B databases whether you're using SQL no SQL or even inmemory databases we also have a module for adding cross cutting features like logging or security without cluttering the main code this is called aop or aspect oriented programming we also have a module for testing of spring components now the beauty of spring is that it's modular so you can pick and choose the modules you need for your project it's powerful and flexible which is why so many developers love it now while the spring framework is powerful using it often involves a lot of configuration for example if you want to build a web application you might need to set up a web server configure routing and manage dependencies manually this can make development slower and more complex that's where spring boot comes in think of spring boot as a layer on top of the spring framework that takes care of all the tedious setup for you it simplifies spring development by providing sensible defaults and ready to use features so why does this matter with spring boot you can go from idea to work in application in minutes instead of hours it saves you time reduces boilerplate code and lets you focus on what really matters building great features for your users by the way the spring framework is just one part of a larger family of projects in the spring ecosystem these projects extend the capabilities of the framework to address specific needs for example we have spring data for simplifying database access we have Spring Security for adding authentication and authorization to our applications we have spring batch for batch processing spring Cloud for building microservices and distributed systems we have spring integration for simplify messaging and integration between systems and more now that you understand what the spring framework and spring boot are and how they fit in the larger spring ecosystem let's start building [Music] before we start building applications with spring boot we need to get our development environment ready first you need the latest version of the Java development kit or jdk so open up your browser and search for download jdk you can find it on article.com now at the time of this video the latest version is jdk 23 it is possible that in the future when you're watching this video there is a newer version of jdk available that's not going to make this course outdated because what I'm going to teach you in this course will apply to Future versions of jdk as well so download the latest version of jdk here as you can see there are distributions for different operating systems Linux Mac OS and windows once you download and install the latest version of jdk open up your terminal window and run Java Dash version to verify that the jdk is installed correctly so as you can see on this this machine I'm running jdk version 23 next we need a code editor in this course I'll be using intelligent idea that's the most popular ID for professional Java and cotland development intelligent idea comes with a variety of built-in tools specifically designed for productive development with spring boot you can also consider alternatives like vs code or Eclipse I personally love intelligent idea especially because of its smart editor it not only autocompletes method name but also suggests entire chunks of code that you can insert with a single P of tab you'll see me doing that throughout the course this makes it much easier to write high quality code faster without getting stuck on syntax or boilerplate I highly recommend using intelligent idea for this course because it simplifies your workflow and helps you focus on learning spring boot instead of dealing with setup issues and here is something great thanks to Jet brins the creators of powerful IDs plugins and services you can try intelligent idea ultimate free for 3 months using the link and promo code below this video now the next step is installing a build automation tool for building and packaging our application here we have two options Maven and Gradle different people have different preferences but in this course we'll be using Maven because it's more popular now if you're using intell you don't need to install Maven separately because intellig has Maven built-in that's one of the reasons I said intellig makes it much easier to get started it comes with all the tools you need to build spring wood applications but otherwise if you're using vs code or Eclipse you'll have to install Maven separately you can download Maven from Maven apache.org now if you're on a Mac you can install Maven with Homebrew it's much easier so open up your terminal first run Brew update and then run Brew install Maven it's much easier to install it this way if you're on Windows I recommend installing Maven using chocolatey in case you are not familiar with it it's a package manager for Windows so first head over to choc.org download and install chocy then open your terminal window and run choco install Maven now once you're done to verify that Maven is installed properly run mvn DV so on this machine I'm running Apache Maven 3.9 [Music] now there are two ways to create a new spring boot project one way is to go to start. spring.io on this page we can select a few options and generate a new spring boot project so first we specify our build tool which can be gril or Maven by default Maven is selected so we keep it as is next we select our language which is Java then we select the version of spring boot at the time of this course the latest stable version is 3.4 .1 there is a newer version but that's a snapshot version so it has experimental features that might be removed in the future so make sure to select the latest stable version now under project metadata we have group which is the group or organization that owns this project by convention we use a reverse domain name so example.com becomes com. example now in my case I'm going to change this to code with MH next we have artifact which is the name of the project I'm going to change that to store because we're going to build an online store in this course now name is the same so whenever we change artifact name gets updated as well we can leave description as is Now package name is the combination of the group and artifact again we're not going to touch this next we have the package type which can be jar or War we're going to use jar and then we specify the Java version in this course we'll be using Java 23 three next we can select our dependencies these are third party libraries or Frameworks we're going to use in our project we'll talk about these later in the section next we go ahead and click generate now this gives us a zip file once you unpack it you can open it with your favorite editor but again I recommend you to use intellig because when using intellig we don't even have to go to this website to create a new spring boot project we can create a project right inside of intellig so open intellig and click new project now on the left side under generators select spring boot now what you see on the right side is exactly what you saw earlier on start. spring.io now I need to highlight that this feature is only available in intelligent idea Ultimate Edition if you're using the Community Edition which I don't recommend you won't see this feature the Community Edition is quite Limited in terms of features so if you want to do professional development you should use the ultimate edition so first first we specify our project name I'm going to change this to store next we specify the location you can put it anywhere you want on your machine it doesn't matter now optionally we can create a git repository I recommend you to do this so you can properly version your code next we specify our language Java our build tool Maven our group I'm going to change this to com. code with MH we leave artifact and package name as is next we specify the jdk version right here we have jdk 23 but what is beautiful about intell is that we can also download the latest version right here so we don't have to go to our browser to download jdk separately from oracle.com okay next we select the Java version I'm going to change this to 23 and click next now up here you can see the version of spring boot that is 3.4.1 optionally we can select our dependencies again we're going to leave this for now and come back to it later so let's go ahead and create our first spring boot [Music] project all right now let's talk about our project structure first we have this folder idea that contains a bunch of configuration files used by intellig you never have to touch these then we have mvn this is part of Maven wrapper which is a way to run Maven without requiring it to be globally installed on your machine with this we can ensure consistent Maven builds across different environments so we can take this project put it on a different machine and build it with the exact same version of Maven and with this we can prevent surprises let me show you what we have here so inside this folder we have the wrapper folder and in this folder we have a configuration file that specifies the version of Maven we're going to build this project with that is 3.3.2 this is different from the maven you have globally install on your machine now once again I want to emphasize if you use intellig you don't need to install Maven globally on your machine because intell comes with Maven built-in okay so this is our configuration file now in this project we also have two Maven rapper files in the rout we have mvnw which is for Mac or Linux and M bw. CMD for Windows both of these files are shell scripts so here we have some code that would automatically download the version of Maven specified in this configuration file okay so that's the mvn folder then we have a couple of files for AR gift repositories that's pretty standard we're not going to talk about them in this course we have help. MD which is a markdown file that contains instructions for getting started again we don't care about it next we have palm. XML this is short project object model and this is the heart of a maven project so in this file we have some configuration about our project and its dependencies now what you see here is a format called XML which a lot of younger developers are not familiar with it's similar to HTML so here we have open and close tags and in between these tags we have some data so here we have all the attributes we specified at the time of creating our project we have group ID artifact fact ID this is the version of our project and so on further down below we have a tag called dependencies which we're going to talk about later in this section so palm. XML is the heart of Maven projects Maven uses this file to download dependencies and build our project now back to our project structure in the source folder we have the actual code for our project we have Main and test in the test folder we write our automated test in the main folder we write the actual code here we have two subfolders Java where we have our Java files and resources where we have non-java files like configuration files as well as static assets like HTML CSS JavaScript and so on in the resources folder we have a configuration file called application. properties here we can have one or more key value pairs so here is a key spring. application. name and the value is store in this file we can specify the server Port our database settings and so on now here in the Java folder we have a package based on the group and artifact we specified when creating this project in this package we currently have one file store application which is the entry point to our application so here we have a Java class and inside this class we have our familiar main method in this method we have a call to Spring app application.run method so that's the basics of our project structure next we're going to talk about dependency [Music] management earlier we talked about dependencies I told you that dependencies are third-party libraries or Frameworks we use in our application for example to build a web application we need an embedded web server like Tomcat we need libraries for handling web requests building apis processing Json data logging and so on now in Spring boot applications instead of adding multiple individual libraries we can use a starter dependency which is a curated collection of libraries and Frameworks that are commonly used together they're tested and verified by the spring development team so in this example if you add the starter web dependency it will bring in a compatible version of these libraries let's see this in action so open up your browser and search for maven Central it's right here central. sonot type.com now Maven Central is a public repository where we can find dependencies for our projects it's similar to npm for JavaScript pipie for python new get for net and so on now here let's search for spring-boot-starter-web all right here is the first item in the result this dependency or this project is owned by or. spring framework. boot now let's click on the dependency name now to use this in our project all we have to do is copy this piece of code in our palom file now this piece of code is dependent on our build tool so up here you can see we have Apache Maven so for Maven projects we have to copy this piece of code but if we use a different build tool like grale then we have to copy a different piece of code okay so back to to Apache Maven now here you can see we have a dependency the group ID is org. springf framework. Boot and the artifact is spring boot starter web we also have the version now let's copy this to clipboard back to intellig let's go to our pom file now in this file we have a tag called dependencies where we can list the dependencies of our project this new project that we have created has two dependencies by default one of them is is spring boot starter the other is spring boot starter test now after these two dependency tags we're going to paste the piece of code that we just copied now here we have an error on the version because intell cannot find this dependency in our local repository it cannot find in our machine to fix this issue we have to click on this m box up here for synchronizing Maven changes so whenever we added dependency to our project we have to click this icon to reload our Maven project and then intellig will download our new dependencies so I'm going to click this now look down here it's resolving this dependencies okay the error is gone so this is one way to add a dependency we go to Maven Central we copy a piece of code add it to our pump file and then reload our Maven project that's one way but there is an easier way first let me remove this new dependency so delete now here we can press command and n on Mac or control and n on Windows to bring up the context menu here we select dependency now in this search box we search for spring Das Boot Das starter D web now if this doesn't work on your machine remove and reinstall intellig that will solve the problem okay now here you can see various dependencies that match the search pattern we're going to select this one from or the springf framework. Boot and this is spring boot starter web version 3.3.2 let's add this to our project once again we have an error here because this version doesn't exist in our local repository so we click on the maven icon here to reload our project and now intellig downloaded this dependency into our local repository now if you look on the right side we have this Maven panel in this panel we have our project here we have a node called repositories so we have two repositories a local repository which is a folder on our machine where these dependencies are stored on Mac it's inside our home folder sl. M2 repository on Windows is probably somewhere like C drive back SL users back SL whatever now we also have a central repository which references Maven Central okay now let's take a look inside the dependencies note So currently we have three dependencies in this project this is the dependency that we just added spring boot starter web now earlier I told you that starter dependencies are curated collection of libraries that work together so if you expand this you can see here we have another dependency for working with Json data we'll talk about this in the future we have a dependency for Tomcat which is our embedded web server we have a dependency to Spring web and spring web MVC these are used for building web applications with these libraries we can process web requests and build apis now one more thing before we finish this lesson when working with spring boot dependencies as a best practice we should remove the version here and let spring boot manage versioning for us let me explain what I mean so first let's remove the version tag okay now let's go to the top here on the top we have this parent tag that references a parent project look at the artifact ID it's spring boot starter parent now if you hold down the command key on Mac or control key on Windows and hover our Mouse over here we can click and go to the P file of this parent project so now we are inside a separate pom file once again here we have a parent tag that references a different project that is spring boot dependencies so once again hold down command on Mac or control on Windows and click here so here is the actual parent or grand parent of our project now if you're on Mac press command and F if you're on Windows press control and F and search for spring-boot-starter-web look here we have a dependency to this package and the version that is specified here is 3.4.1 similarly we have other dependencies and their versions and these are tested to work together so back to our P file using this mechanism we allow the dependencies that we had here inherit their version from this parent project so if they're listed in the parent project that version that is compatible with our project will be used here otherwise Maven will use the latest version of those dependencies now this has two benefits one benefit is that it simplifies our pom fight so down here where we specify our dependencies we don't have to include their version the other benefit is that if you upgrade the version of spring boot all dependency versions are automatically updated to their tested compatible counterparts so as a best practice when working with spring boot dependencies we should remove the version and let spring boot manage versions for us [Music] in this lesson we'll create our first controller to handle requests to the homepage and serve a simple HTML file but before we start coding let's take a moment to understand the basics of spring MVC which is the foundation of how we handle web requests in Spring boot spring MVC stands for model view controller and it's part of the spring framework that helps us build web applications it provides a clean way to separate different parts of our application making it easier to manage and scale model is where our application's data lives it represents the business logic and is usually connected to a database or other data sources in Spring boot the model can be a simple Java class the view is what the user sees it's the HTML CSS or JavaScript that's rendered in the browser in Spring MVC views can be static files or dynamically generated using tools like time Leaf the controller is like a traffic control controller it handles incoming requests from the user interacts with the model to get data and then tells the view what to display let's see this in action so back to our project here in the Java folder inside this package let's right click and add a new Java class we're going to call this home controller now intellig is asking if you want to add this to our git repository I'm going to select don't ask again so we don't see this in the future let's go ahead and add this to our repository okay now to make this a controller we have to decorate it with the controller annotation so here we type an AD Sign followed by controller and then press enter so this annotation is defined in this package org. springframework do stereotype okay now I believe I covered annotations in my Java course but very briefly an annotation is like a label or a tag that we add in the code to give instructions or additional context to the compiler we can apply them to classes methods Fields parameters and so on so in this example by adding this annotation to this class we are telling spring that this class should be used as a web controller for receiving web traffic now inside this class we add a method public string we can call this method anything we want but I'm going to go with index now when we send a request to the root of our website we want this method to be called to do that we have to apply another special annotation here that is request mapping now this other annotation is defined in this package or. springf framework. web this is part of the web starter dependency that we added in the previous lesson okay so we add this annotation and then give it an argument that is a URL pattern here we can type a forward slash that represents the root of our website so when a request goes to the root of our website this method gets called if you want to receive traffic at a different endpoint like about or contact we can change the argument here okay so let's go back to the root of our website now in this method we return the name of the view that should be returned to the browser so we return index.html okay now we need to create this view back to our project we go to the resources folder this is where we add non Java files now here we add a new folder called Static and inside the static folder we add a new file well a new HTML file called index.html now in this HTML file inside the body element we type H1 Tab and and inside the H1 tag we type hello world so this is our view now we're not going to cover models in this lesson we'll cover them later in the course next I'm going to show you how to build and run this application hey guys thanks for sticking with me so far just a quick break if you're enjoying this tutorial I wanted to let you know that this is just the first hour of my complete spring boot course the full course has two parts with each part being about 6 hours long it covers a whole lot more taking you from the basics all the way to advanced concepts you will learn everything you need to build real world backends with spring boot so after you watched this tutorial if you want to learn more and level up your skills check out the link in the description below and enroll in the complete course now let's jump back [Music] in all right now let's talk about running our application if you're using intellig you can run this application by clicking the play icon on the toolbar look at the shortcut it's contrl and R so I'm going to press that our application is built now here on the console window if you scroll to the right you can see that Tomcat which is our embedded web server is initialized with Port 880 so now if you open our browser and navigate to Local Host Port ad8 we can see our homepage beautiful now let me show you a different way way to run this application back to intellig first I'm going to stop this now if you're not using intellig you can run this application using Maven first we have to open a terminal window and go to our project folder I've put this project on my desktop inside spring boot SL demo store so right now I'm inside the project folder you can see that in the terminal I'm on the main branch of my git rep repository so if you're run LS on Mac or Linux or there on Windows we should be able to see our project files so look earlier we talked about these two files and VNW that is a maven wrapper so if you don't have Maven globally install on your machine you can use the maven wrapper now here on Mac or Linux to run this we have to type period slash mvnw then we type a space followed by- V so as you can see I'm running Maven 3.9.0 now if you're using Windows you have to type mvnw CMD space- V actually I think CMD is optional but I'm not entirely sure I haven't used windows for over 10 years so excuse me if I'm making a mistake here anyway so now with this Maven wrapper we can run our spring boot application but instead of- V we're going to type spring Das Boot colon run take a look Maven compile our application so now once again if we go back to our browser and navigate to this address we should see our homepage you have probably seen this guy before in my other courses his name is John Smith he's our self-proclaimed Rockstar developer who claims he writes bug free code according to John debugging is something other people need to do but let's be real bugs happen to all of us even if you're as perfect as John Smith thinks he is so in this lesson I'm going to show you a few different techniques for debugging your spring board applications back to our home controller let's make a few small changes and introduce a bug first let's define a private method that returns a string we call this get view name and here we return index instead of index.html now back our index method first we declare a variable called view name and here we call get view name and then we return view name obviously this is unnecessary this code is very redundant but we are deliberately doing this for the purpose of debugging now let's rerun our application so we press contrl and R intellig is saying that this process is running it's asking us if you want to stop and restart the web server let's go ahead all right good back to the browser let's refresh all right now we have an error because there is no view called index our view file is index.html so let's see how we can find this book back to our home controller the simplest way to debug this application is using a print statement so before we return the name of the view we can type system. out. printline view name now let's rerun this application okay back to the browser refresh now we go back to intellig here on the console window we can see the output of our print statement so we are returning index which is not a valid view name so this is a simple way we can debug our applications but we can also use the debugging Tools in intellig or other IDs to do that first let's remove this print statement all right now we're going to start our application in the debug mode and executed line by line to do that first we have to insert a breakpoint in our code a breakpoint is a marker that tells intellig to pause our application when the program reaches that line of code for example here we can add a breakpoint by clicking in the left margin this red dot represents a breakpoint we can click it again to remove it so we insert a breakpoint now we start the application in the debug mode and the execution stops right here here to do that instead of clicking the play button we should click the debug button look at the shortcut it's controll and D so I press contrl and D rerun our application in the debug mode okay our web server is listening on Port 880 so now we go back to the browser and refresh this page so our home controller is hit so refresh okay here we are and the execution stopped right here on this highlighted line now this line is not executed yet we can execute it line by line using this tool over here step over the shortcut is f8 so if you press f8 this line is executed and now inside this little window we have the variables that are meaningful in the current context so we have this which is a reference to the current object which is home controller we also have view name which is set to index so using this window we can verify that our variables have the right values now if a variable is not detected here we can add an expression here for example view name and here's the result okay now we don't need this so let's remove it so this is how we can use step over now we can step over this line as well so we press f8 now we are inside the source code of the spring framework now this is not the actual source code this is the decompiled class but we don't care about this code because this is not part of our application we want to debug right so we want to continue execution until something is rendered in the browser to do that we have to use a different tool look at this button this is for resuming program the shortcut on Mac is option command and R so I'm going to press these Keys all right now all the code has been executed and here is the result now back to our home controller let's say we haven't found the bug yet so we want to restart the debugging session again we press contrl and D now we go back to the browser and refresh this page so our home controller is hit but this time instead of stepping over this line we're going to step into it maybe there is a problem with this method to do that we use this button over here step into the shortcut is F7 so we press F7 and now we are inside this method here we have only a single line of code we could have tens or hundreds of lines of code and this method could call other methods so again we could step over or step into those lines until we would find the source of the problem now in this case we know the problem is with the string literal that we are returning so let's change that to index.html now that we're done we stop the debugger and remove this breakpoint we don't want to leave these break points all over the code because they're going to get in the way in future debugging [Music] sessions you have noticed that every time we change our code we have to rebuild our project but in Spring boot we also have the automatic restart feature it's not ideal it's not as fast as automatic restart we have in node or react because there is a little bit of delay but let me show you how to set it up first we have have to go to our pom file now let me show you a cool shortcut here we can press shift command and o on Mac or shift control and o on Windows now over here we can search for our files so pal. XML now here we're going to add a dependency to do that we press command and n on Mac or control and n on Windows we select dependency and search for spring-boot das Dev tools okay now look at this dependency from org. springf framework. boot so we add this to our project first we remove the version because this dependency is part of the spring framework so it's better to allow the parent element determine the version of this dependency so let's delete this line instead we add another tag called optional and we set it to true that means this is not part of our application code it's not going to be packaged with our application to be deployed in the production it's only used during development okay now we have an error because this dependency does not exist in our local Maven repository so we have to click this button to reload our project now Maven downloaded this dependency good now to use this in intellig there are two settings we have to modify we go to the top on intellig IDE menu we go to settings now on Windows I think settings exist under file or edit menus okay regardless find the settings page now up here search for compiler now under build execution and deployment here under compiler check this box build project automatically that's the first setting there's one more setting we have to modify here on the top search for advanced settings right here under advanced settings check this box allow automake to start even if developed application is currently running so check this box all right now let's reassort our application all right with this in place every time we change our code after a small delay our application gets restarted let's see it in action so let's go back to our home controller and change index.html to index okay now after a few seconds our application gets restarted this is not ideal it's not as fast as what we have in environments like node or react it is what it is but I thought to cover it in the course because a lot of people use this tool all right our application got restarted so back in the browser if you refresh we can see the homepage is broken so this is the def tools now I personally am not a fan of this tool so whenever I make changes I like to restart the application using control and R but going forward I'm going to check this box so this doesn't get in the way and we can quickly see the result now let's change this to index.html and move on to the next lesson in every application there are settings we'll need to configure like which Port the application runs on database credentials or even custom settings for our application so let's see how we can configure our application properties here in the resources folder we have this file application. properties we briefly talked about this before here we have a bunch of key value pairs some of them are standard like spring. application name we have several standard properties like server. Port the default value is 8080 but we can change it to whatever we want and this will be the port our application will listen on I'm going to remove that we can also Al Define custom properties like app dot whatever like page- size okay now to use this properties in our code we have to use the value annotation let's see how this works so first we go to our home controller to do that we press shift command and o on Mac or shift control and o on Windows let's go to our home controller okay now in this controller we want to define a private field and initialize it with the value of spring. application. name so let's declare a private field private string we can call that app name or whatever now we should annotate this with the value annotation we press enter so it's imported on the top it's defined in this package or. springf framework. beans. factory. annotation okay now as an argument we should pass a string with a special syntax first we type a dollar sign and inside braces we type the key of an application property in this case I'm going to copy this key spring. application. name now at runtime spring will get the value associated with this key and injected into our private field so now to see this in action we can use a print statement so system.out print line and here we can print the application name okay let's rerun our application and refresh the homepage okay now here on the console look app name is store one of the core features of the spring framework is dependency injection it's a powerful concept that is used in real world applications in this section we'll start by breaking down what dependency injection is why it's important and how it helps make your code cleaner and easier to maintain you'll learn how to implement it using Constructors and Setters we'll then dive into how spring boot handles dependency injection using the ioc container you'll see how to configure beans with annotations control which beans are selected when multiple options are available and externalized configurations to make your application more flexible finally will explore Advanced topics like configuring beans programmatically using lazy initialization managing Bean Scopes and controlling the life cycle of your beans by the end of this section you'll have a strong understanding of dependency injection and how spring uses it to manage the components of your application efficiently now let's jump in and get [Music] started so what is dependency injection many students find this concept confusing or complex but it's actually very simple let's break it down with a real word example imagine we're building an e-commerce application we have an order service class that handles placing orders when an order is placed the customer's payment needs to be processed so order service depends on a payment service like stripe payment service in this case we say order service is dependent on or coupled to strip payment service at first glance this might seem fine but let's talk about the issues that arise when one class is tightly coupled or dependent on another the first problem is that order service can only use stripe payment service if tomorrow we decide to switch to a different payment provider like PayPal we would have to modify the order service code and once we change the order service class it has to be recompiled and retested which could impact other classes that depend on order service the second problem is that we cannot test order service in isolation because order service is tightly coupled to strip payment service we can test its logic separately from strip payment service now the problem here isn't that order service depends on strip payment service dependencies are normal in any application the issue we have here is about how the dependency is created and managed let me give you an analogy think of a restaurant a restaurant business needs a chef right so there is a dependency between the restaurant and the chef if the current Chef becomes unavailable available the restaurant can hire another Chef this kind of dependency is totally normal but what if we replace chef with John that means our restaurant is now dependent on Jon a specific Chef what if Jon becomes unavailable we can't replace him with someone else and the restaurant will be in trouble this is an example of tight or bad coupling now back to our e-commerce application we don't want order service to be tightly coupled to a specific payment service like stripe that's like a restaurant being dependent on a specific Chef instead we want order service to depend on a payment service which could be stripe PayPal or any other provider to achieve this we can use an interface to decouple order service from strip payment service an interface in Java is like a contract that defines the capabilities of a class it doesn't contain any implementation or logic it simply lists the methods or capabilities a class should have for example if order service depends on a payment service interface it doesn't know anything about stripe PayPal or any other payment provider as long as these providers implement the payment service interface they can be used to handle payments and Order service wouldn't care which one is being used so here are the benefits if you replace strip payment service with Paypal payment service the order service class is not affected we don't need to modify or recompile order service also we can test order service in isolation without relying on a specific payment provider like stripee now with this setup we just have to give order service a particular implementation of payment service this is called dependency injection meaning we'll have to inject a dependency into a class just like how we can inject a drug into a body we can also inject an object into a class now there are a few different ways we can do this and we're going to cover them over the next few lessons but first let's jump into the code and set up our example all right back to our project here in this package let's add a new class we're going to call this order service now let's give it a method public void place order now in a real application we should pass an order object here but let's keep things simple and focus on dependency injection so no parameters now here we need to use a payment service like stripe so first we go back to our project and and add another class here stripe payment service now in this class we add a method public void process payment now in a real application we should pass a payment object here that encapsulates payment information like credit card details but again to keep things simple let's just add a simple parameter like a double here double amount now in this method let's add a print statement let's change the message to amount we just print the amount and right above that we add another print statement and say stripe now in the future we can create another payment service like PayPal and in that class we'll print PayPal okay now our order service needs to use strip payment service so back to this method here we declare variable payment service and set it to a new instance of stripe payment service then we call payment service process payment that's hardcode a value like $10 okay now this is our earlier setup before we introduce an interface to decouple these two classes so in this implementation the order service class is dependent or tightly coupled to stripe payment service so that means we cannot test order service in isolation because whenever we want to test that we have to bring in strip payment service and also if in the future we decide to switch to a different provider like PayPal we'll have to modify the order service class as a result of this the class has to be recompiled retested and this can propagate to several other classes in our application so this is where we use an interface to decouple or order service from stripe payment service to do that we go back to our stripe payment service on the top under the refactor menu go to extract and then interface now on this dialog box first we specify our interface name we're going to use a more General name so we remove stripe and just call this payment service we leave it in the same package and then down here we select the method that we want to include in the interface by default it's not selected so make sure to select it and then click refactor now intellig is saying that this interface has been successfully created it's asking if you want to proceed yes and then it says use interface where possible this is called programming against interfaces okay let's go ahead look what happened now strip payment service implements payment service let's take a look here so we hold down command on Mac or control on Windows and click here this is our interface as you can see this interface has no implementation there is no logic here no algorithm all we have is a method declaration or a capability this is like a chef that can cook but how they cook we don't know that is dependent on the implementation okay now with this setup we have to modify order service so instead of being coupled to strip payment service it should be coupled to payment service we'll do that next one way and the recommended way to inject a dependency into a class is via Constructor so here in the order service let's define a Constructor public order service we press tab to complete the code now we should pass our dependency as an argument to this Constructor so first we give it a parameter of type payment service we press Tab and tab again so we receive a payment service object here now we should store this in a field in this class so we can use it in the place order method so we can declare a private field private payment service Tab and then initialize it in the Constructor intellig automatically detected the code we want to write so we can just press Tab and here it is so when creating an order service we pass a payment service object we store it in a field in this class which is declared up here and then in the place order method instead of using strip payment service we use the payment service object that we have in this class this is our setup now to see this in action we should go back to our project and go to the store application class we're going to take a break from spring so we're going to comment out this line so instead of running a spring application we're going to run a console application so here in the main method first we declare a variable called order service then we set it to a new order service now here in the Constructor we have to pass a payment service this is our chance to inject a dependency into the order service class so we can pass a new strip payment service or in the future we can pass a different payment service like PayPal okay now we can call order service place order let's run our application all right look we are using stripe to process $10 now let's create a new payment service so in this package we add a new Java class called Paypal payment service now here we say this class implements payment service so we press tab to complete the code now we have an error because this class is not implementing the methods declared in this interface so we can press alt and enter and here we select Implement methods in this dialog box we can see all the methods declared in our payment service interface by default this is selected otherwise we have to select it and then we click okay so here's our implementation now to save time I'm going to go back to our stripe payment service copy these two lines and paste them in our PayPal class we just have to change stripe to PayPal okay now with this change we can go back to our store application and when creating a new order service we can give it a new PayPal payment service now if you run the application we can see that PayPal was used to process $10 but here's the interesting part as a result of supporting PayPal payments we didn't have to modify our order service so we extended our application by creating new classes instead of modifying existing ones in object-oriented programming this is called open closed principle it's a very important principle in building maintainable software the open close principle says that a class should be open for extension but closed from modification in other words we should be able to add new functionality to a class without changing its existing code now why is this important because by avoiding changes to existing code we can reduce the risk of introducing bugs and breaking other parts of the application now of course this is just a guideline it doesn't mean we need to blindly apply it everywhere in our application like any principle it's something we should strive for when it makes sense and adds value now you might have seen people like our famous Rockstar developer Mr John Smith who hate object-oriented programming one reason might be that they read principles like the open close principle in a book applied them blindly to every corner of their application and ended up with an over engineered mess and of course instead of blaming their own misuse of the principles they blame object-oriented programming itself the takeaway here is that principles like the open close principles are tools not rules they're meant to guide you in building flexible and maintainable software but you should always use them with common sense [Music] another way to inject a dependency into a class is via a Setter so here in the order service class we're going to define a Setter for setting the payment service now we can type that Setter by hand or we can have intelligate generated for us first we put the cursor on the field name then we press command and n on Mac or control and n on Windows to bring up the generate context menu here we select Setter enter and proceed all right here's our new Setter so this Setter gets a payment service and sets the payment service field in this class now I don't like that intellig inserts the generated code on the top because by convention we put Getters and Setters in the bottom so let me show you another cool shortcut for moving this code first we put the cursor on the method Declaration on the first line now we hold hold down shift and command on Mac or shift and control on Windows Now by pressing the down or up arrows we can move this method around okay I'm going to move it to the bottom so here it is now to use this we go back to our store application here we call order service do set payment service and pass new Paypal payment service now of course this looks a little bit ugly because we don't want to pass the payment service twice so it would be better to remove the payment service from Constructor and then pass it to the setter so back to our order service we can remove or comment out this Constructor the shortcut to do that is command and slash on Mac or control and slash on Windows okay now back to our store application we create an order service we set the payment service and then then place the order now there's a problem with this code can you tell here's the problem what if we forget to set the payment service now if you run our application it crashes we have a null pointer exception so we should use this approach for optional dependencies in other words our order service should be able to do its job without having that external dependency in this case a payment service is not an optional dependency it's a required dependency so it doesn't make sense to injected bya Setter again for the most part Constructor injection is the more common and the recommended way to inject dependencies so far we have been manually creating a payment service and passing it to order service while this works for simple examples it quickly becomes a headache as our application grows what if Paypal payment service has its own dependencies we would have to create more objects and wire them together managing all of this manually can get messy tedious and aror prone this is where spring comes to the rescue one of the core features of the spring framework is its ability to create objects and inject them into our classes automatically at the core of the spring framework we have what we call an ioc container we'll talk about ioc in a minute but this container is responsible for managing the objects in our application in Spring terminology we refer to this manage object objects as beans so a bean is just a regular Java object that is managed by a spring spring takes care of creating it injecting its dependencies and even managing its life cycle now what is ioc about well ioc is short for inversion of control the name comes from the fact that it inverts the control of creating objects and managing dependencies in a traditional application we are in control we write the code to create objects and manage dependencies but with the ioc container we hand over that control to Spring let's see this in action so I'm going to bring back this line now this run method returns an object of type application context application context is our ioc container it's a storage for our objects so we can store the result in an object of type application context that is defined in this package or. springframework doc context so we import it and call this object context now this context has a method called get bean with this method we can get a bean or an object that is managed by a spring in this case we need a being of type order service right so as an argument we pass order service do class okay then we store the result in order service so instead of us manually creating objects and injecting tencies we let spring take care of that for us so let's remove this line okay now let's run our application all right our application crashed with an exception of type no such being definition exception the message says no qualifying being of type order service available in other words spring doesn't know how to create an instance of order service there are two ways we can solve this issue we'll talk about about them [Music] next there are two ways we can tell spring about objects it should manage for us one way is using annotations and that's what we're going to cover in this lesson there is another way using Code which we'll look at later in this section so back to our main method look here we need to get a be of type order service so we want spring to manage objects of type order service to do that we go to our order service class and annotate this with an annotation called component this is defined in org. springf framework. stereotype so let's press enter so this is imported on the top okay so with the component annotation we tell spring to manage objects of type order service now component is a general purpose annotation we have other specialized annotations like service for classes that contain business logic we have repository for classes that interact with the database we have another annotation that you have seen before and that's controller this is used for markting classes as controllers for handling web requests so back to our code order service is a service class so here we can also use the service annotation now technically service is just an alias for the component so there's really no difference between the two let me show you what I mean so hold down command on Mac or control on Windows and click service look at the implementation look service is an alias4 component so we can use either of these annotations but the component annotation is often used for utility classes we use service for classes that contain business logic now look down here we have an error saying could not autowire no beans of payment service type found what this error is saying is that order service needs a payment service but payment service is an interface so spring doesn't know how to create instances of the payment service interface to solve this problem we have to go to the Paypal payment service class and annotate this with either component or service now technically we should do the same with the stripe payment service but don't do that in this lesson because that's going to cause an issue that we'll talk about later in this section okay so we simply annotated two classes with service now if you run our application we can see that PayPal was used to process $10 beautiful now there is another annotation you need to be familiar with and that is autowired let's go back to our order service class so here we have a Constructor that takes a payment service now in the past we had to annotate this Constructor with autowired to tell spring to autowire this object with its dependencies but going forward this is not necessary if our class has a single Constructor so in this case we can comment this out and everything works but you might see The autowired annotation in a lot of older code bases now if you have multiple Constructors here we have to use autowired let me show you this in action so I'm going to temporarily comment this out now let's create a default Constructor order service now if you run our application our application crashes with a null pointer exception because in this example spring prefers to use the default Constructor with no arguments and as a result payment service will remain uninitialized to solve this problem we have to bring back The autowired annotation now when we run our application everything works as expected because we have told spring to autowire this class with its dependencies okay now what if we have another Constructor but not a default Constructor so let's add payment service here and give it a second parameter like int X it doesn't really matter now look what happens if you remove the auto annotation right away we can see an error here saying class doesn't contain matching Constructor for auto wirring but let's run the application and see the error we get because that's a very common error in Spring applications so let's run this one more time all right now we got an exception of type Bean creation exception and the message is error creating Bean with the name order service this is a very common exception so to solve this issue again we have to bring autowire back so bring Auto wires this class with its dependencies let's run our application one more time problem is solved so let's remove this other Constructor as well as the autowire out ation and move on to the next lesson if you found this useful imagine what you will learn in my full spring wood course as I said the full course has two parts but each part about 6 hours long it covers a whole lot more and is packed with exercises to make you a job ready developer click the link below and start learning today
lvg8pBJ2kFg,"hi guys many of you have been asking me for a spring boot course and after a long wait it's finally here spring boot is the go-to framework for building modern Java applications and learning it is one of the best investments you can make in your career companies are actively hiring Springwood developers with salaries ranging from 160,000 to 300,000 per year according to glass store I know that for many developers spring boot can feel overwhelming that's why I've put together this clear structured non nonsense Cor to teach you spring boot the right way this is a two-part series and in the first part we focus on two of the most fundamental aspect of spring boot dependency injection and database integration with spring data jpa but we don't just cover the basics we go really deep touching on Concepts that most other courses either gloss over or don't cover at all this course is packed with real world exercises to help you truly understand and apply what you learn I've put my heart and soul into creating this course and I can't wait to share it with you the course is dropping soon so make sure you're subscribed and have notifications turned on so you'll be the first to know when it's live see you in the course"
K5KVEU3aaeQ,"[Music] welcome to the complete python Mastery course in this course you're going to learn everything about python from Basics to more advanced concepts so by the end of the course you'll be able to confidently use Python for AI machine learning web development and automation if you have been looking for a comprehensive easy to follow well organized and practical course that takes you from Zero to Hero this is the right python course for you you don't need any prior knowledge of python to get started I will explain everything step by step in simple terms so you can build a solid foundation I'm m hamadani a software engineer with over 20 years of experience and I've taught Millions how to code and become professional software Engineers through my YouTube channel and online school quote withm mar.com if you're new here make sure to subscribe as I upload new videos all the time now let's jump in and get [Music] started in this course you're going to learn everything you need to get started with python just be aware that I've designed this course for beginners so if you have some programming experience check out my other python course for developers you can see the link on the top right corner of this video so python is the world's fastest growing and most popular programming language not just amongst software developers but also amongst mathematicians data analysts scientists accountants Network engineers and even kids kids in fact it's the ideal programming language to learn first but what makes python so special here are six reasons with python you can solve complex problems in less time with fewer lines of code than many other languages that's why huge companies like Google Spotify Dropbox and Facebook have embraced this beautiful and Powerful language here is an example let's say we want to extract the first three characters of the text hello work this is the code we would have to write in C this is how we would do this in JavaScript and here's how we would do it in Python see how clean and simple the language is and that's just the beginning python is a multi-purpose language and you can use it for a wide range of jobs such as data analysis Ai and machine learning writing automation scripts building web mobile and desktop applications as well as software testing or even hacking so if you want a high-paying long lasting career in any of these areas especially Ai and machine learning python is the language to put those opportunities at your fingertips in fact according to indeed.com the average salary of a python developer in the US was over $115,000 in March 2018 and here are four more reasons that make python the most desirable language python is a highle language so you don't have to worry about complex tasks such as memory management as you do in C++ it's crossplatform which means we can build and run python apps on Windows Mac and Linux it has a huge community so whenever you get stuck there is someone out there to help and it has a large ecosystem of libraries Frameworks and tools whatever you want to do it is likely that someone else has done it before because because python has been around for over 20 years there are two versions of python out there python 2 which is the Legacy version of python and is going to be supported until year 2020 and Python 3 which is python for the future in this course you're going to Learn Python 3 hi my name is msh hamadani and I'm going to be your instructor in this course I'm a software engineer with 18 years of experience and I've taught way over a million people how to codee or how to become top professional software Engineers to learn more about me and my courses head over to Cod with.com all right now let's get started all right the first thing I want you to do is open your browser and head over to python.org on this page under downloads you can download the latest version of python at the time of this video the latest version is python 3.13 chances are in the future when you're watching this video there is a new newer version of python available don't worry what I'm going to show you in this tutorial will apply to Future versions of python as well so go ahead and download the latest version now if you're on windows before you click install make sure to check this little box here that says add python to path this step is very important and it will save you a lot of headaches later so check this box and follow the installation now to verify that python is successfully installed click this magnifier and and here in this search bar type terminal now here in the terminal window type python D- version this verifies that we have successfully installed python 3.13 now if you're on Mac press command and space to bring up the spotlight search here type terminal now to verify that we have installed python correctly on Mac we should type Python 3 space-- version so as you can see I've successfully installed python 3.13 on this machine so this environment you see here is what we call python interpreter which is basically a program that executes python code we can type our python code in a file and give it to this interpreter or we can type our code directly here in this interactive shell so here we can write an expression like two + 2 in programming an expression is a piece of code that produces a value so here when we add 2 + 2 we get a value that is why we refer to this piece of code as an expression so enter we get four let's try a different kind of expression let's see if two is greater than one we get true which is an example of a Boolean value you're going to learn about these Boolean values in the next section now what if we type two is greater than five enter we get false so in programming we have true and false which are similar to yes and no in English now what if we type two is greater than but we don't add a second value here just press enter we get a syntax error in programming syntax means grammar so just like we have the concept of grammar in the languages that we speak we have the exact same concept in programming if we write a sentence that is not grammatically correct chances are some people may not understand that sentence so in this example we have this expression which is incomplete it doesn't have the right grammar or syntax that is why python interpreter is complaining by returning an error so this interactive shell is a great way to quickly experiment with a bit of python code but that's not how we build real world applications to do that we need a code editor and that's what I'm going to show you in the next lecture [Music] when it comes to typing python code you have two options you can use a code editor or an IDE which is short for integrated development environment an IDE is basically a code editor with some fancy features like autoc completion which means as you type code this feature helps you complete your code so you don't have to type every character by hand it's a per activity boosting feature it also gives you additional features like debugging which means finding and fixing bugs in your programs testing and so on for both code editors and Ides there's so many options out there the most popular code editors are vs code atom and Sublime you can use the code editor that you prefer in terms of the Ides again there are so many options out there the most popular one is pie charm in this course I'm going to use vs code or Visual Studio code because that's my favorite code editor later in the course I will show you how to install a Plugin or an extension that will convert vs code to a powerful ID so before going any further head over to code. visual studio.com and download the latest version of vs code now with vs code open on the top from the file menu go to to open and somewhere on your disk create a new folder let's call this folder hello world and then open it beautiful now click this icon on the top this opens up the Explorer panel in this panel you can see all the files and folders in your project so let's add a new file and call that app.py so all our python files should have the p my extension press enter now let's close this and type a bit of python code in this lecture we're going to use one of the built-in functions in Python called print so in Python we have a lot of buil-in functions for performing various kinds of tasks for example as a metaphor think of the remote control of your TV on this remote control you have a bunch of functions like turn on turn off change the channel change the volume and so on these are the build buin functions in your TV we have the same concept in Python and many other programming languages so one of these built-in functions that comes with python is print and we can use this to print something on the screen now whenever you want to use a function you should open and close parentheses in programming we say we're calling the print function calling a function means executing it now let's display the hello world message on the screen whenever you want to work with text you should put your text in between quotes either double quotes or single quote now I'm going to go with double quote and add hello world and then put a happy Persian cat here beautiful save the changes with command and s on Mac or control and S on Windows now to execute this code we need to go back to command prompt on Windows or terminal on Mac but the good news is that we don't have to switch programs here in vs code we have an integrated terminal so press control and back tick that is the key before number one on your keyboard that is just below the escape button so this is our integrated terminal now if you're on Windows type python if you're on Mac or Linux type Python 3 and next to that add the name of our file that is app p and here's our hello word message in the terminal beautiful now let's take this to the next level and make it a little bit more interesting let's close this terminal window by pressing control and back tick and add a second line of code so one more time print this time let's add quotes with a star in between them now let's say you want to repeat this star 10 times so here we can multiply this is by 10 save the changes open up the terminal and run our program and you can see this star is repeated 10 times so as you see the instructions in our program are executed from top to bottom in order in the next lecture I'm going to show you how to convert this vs code to a powerful IDE for building python applications [Music] in this lecture I'm going to show you how to convert vs code to a powerful IDE by using an extension called python with this extension or plug-in we get a number of features such as linting which basically means analyzing our code for potential errors we also get debugging which involves finding and fixing errors we'll look at this later in the course we also get autoc completion which basically helps us write code faster so we don't have to type every character we get code formatting which is all about making our code clean and readable just like how we format our articles newspapers books to make them clean and readable we get unit testing which involves writing a bunch of tests for our code we can run these tests in an automated fashion to make sure our code is behaving correctly and finally we get code Snippets which are reusable code blocks that we can quickly generate so we don't have to type them all by hand now don't worry about memorizing any of these as we go through the course you're going to learn about these features so back to vs code on the left side click this icon this opens the extensions panel where we can install additional extensions to enhance vs code up here in the search bar search for python all right look we have an official extension for python from Microsoft so go ahead and install this now you might see a box here saying reload if you see that make sure to click it to reload vs code now with this extension installed we have a ton of new functionality in vs code for writing python code the first one I'm going to show you in this lesson is the ability to run our code so back to app.py look with this extension installed now we have this play icon on the top for running our code so if we click it we can see the output of our program in the terminal window in this lecture I'm going to show you linting and action so let's start by writing some invalid code like this print space with no parenthesis and then hello world earlier I told you that print is a built-in function and whenever you want to use or call a function you should always use parenthesis now to be more precise this is actually valid python 2 code but because we're using Python 3 here this is invalid code from python 3's point of view so now when I save the changes you can see this red underline here let's hover our Mouse over this underline you can see this tool tip it's coming from Pilot and here's the error message missing parenthesis in call to print did you mean print with parenthesis so this is the benefit of lenting as you're writing code you can see potential problems in your code you don't have to wait to run your program to see these errors so now if we put parenthesis here and save the changes you can see that red underline is gone let's look at another error let's type two plus and then save the changes earlier we run this code in Python interpreter's interactive shell there we got a syntax or grammar error so if you hover your mouse here one more time you can see pilent is telling us that this is invalid syntax or invalid grammar it's like an incomplete sentence so this is linting an action now let me show you a couple useful shortcuts here on the top look at the view menu here we have this problems menu look at the shortcut on Mac it's shift command and M on Windows it's probably shift control M so as you're working with vs code try to memorize these shortcuts because they really help you write code faster now let's take a look at this problems panel so this problems panel lists all the issues in your code in one place so if you have an application with multiple files this is really useful because some of those files may not currently be open so this linter pilent will analyze all your files and if it finds any issues it will list them here in the problems panel now you can also put this on the right side of the screen so let's put it here so so as you write code these problems will appear here now let's fix this issue so I'm going to add three here save the changes and you can see the problem disappeared and one last thing before we finish this lecture once again on the top let's go to the view menu the first item is command pallet this is a very important feature in vs code once again look at the shortcut that is shift command and P on Mac or shift control p on Windows with this command pallet you can execute various commands in vsod if you type lint here you can see all commands related to linting as you can see all these commands are prefixed with python because these commands come with the python extension that we installed earlier so these are additional features available to us in vs code the First Command here is Select linter in this list you can see various linters available for p pent so as you're reading tutorials or talking to other people you will hear about linters such as flake 8 my pie pep 8 and so on different developers prefer different linters I personally prefer py lint that is the most popular one and that is the default linter set and the python extension of vs code if you're adventurous you can try using other linters on your own the difference between these linters is in how they find and Report errors some error messages are more meaningful or more friendly the others are more ambiguous so that's all about linting in the next lecture we'll talk about formatting code in Python Community we have a bunch of documents called python enhancement proposals or peps here on Google if you search for python peps you can see the list of all these PS under python.org sdev peps let's have a quick look here so here are the peps you can see each pep has a number and a title the one that is very popular amongst python developers is Pep 8 which is a style guide for python code a style guide is basically a document that defines a bunch of rules for formatting and styling our code if you follow these conventions the code that you right will end up being consistent with other people's code now if you have time you can go ahead and read this pep eight documentation but if not don't worry because throughout this course I'm going to explain the key things in pep 8 in this lecture I'm going to show you a tool that helps you automatically format your code according to pep 8 so back in vs code let's write some python code x equal 1 here I'm declaring a variable and setting it to one if if you're not familiar with variables don't worry in the next section you're going to learn about them so according to pep 8 this code is considered ugly because by convention we should add a space around this equal sign or the assignment operator now since you're starting out with python you probably don't know these rules so let me show you a tool that helps you automatically format your code let's revert this back to its original state now we need to go back to the command pallet remember so it's right here under View and the shortcut is shift command and P here if you search for format you can see this command format document the first time you execute this command you're going to see this message here formatter autopep8 is not installed so there are a bunch of tools for formatting python code the most popular one is Auto Pep 8 and this is the tool that this python extension we installed uses to format our our code now if you don't see this you can install autopep8 using the extensions panel so once again on the left side click this icon and search for Auto Pep 8 there it is let's install it good so let's go ahead and install this good now one more time let's open up the command pallet and execute format document see this tool automatically formats our code beautiful let's take a look at another example I'm going to declare another variable Y and set it to two and a variable with a long name like unit underline price and we set this to three now some developers have this habit of formatting their variable declarations like this so they put all these equal signs in the same column according to pep 8 this is considered ugly so once again let's format our code that is better beautiful now let me show you a trick opening up this command palet and searching for format document every time is a little bit timec consuming so I'm going to show you how to have your file automatically formatted as soon as you save the changes on the top let's go to the code menu preferences and settings here in the search box search for for format on save so we have this option editor format on Save take this now back to app.py I'm going to change the formatting of these lines make them really ugly now as soon as I save the changes you can see my code is reformatted [Music] beautiful all right now let's talk about a few different ways to run python code as I told you before one way to run python code is by opening the terminal window if you're on Windows type python if you're on Mac type Python 3 followed by the name of the file this approach is useful in situations where you don't have access to a code editor okay now with the python extension in vs code there is a simpler way to run python code we get this play button on the top when we click it we see the output in the terminal but clicking this button every time we change our code is a little bit tedious so let me show you how to associate a shortcut to this button first we close this next we bring up the command pallet the shortcut on Mac is shift command and P on Windows is shift control P here we search for open keyboard shortcuts look we have this command up here now on this window we can see all the commands in vs code and the shortcuts associated with them here in the search bar search for run python file okay so this is the command that is associated with the play button as you can see we don't currently have any key bindings or shortcuts here so double click in this column now here you can press any key combination for creating a shortcut I'm going to press controll and R okay now we press enter with this in place we can go back to app.py and press controlr and here we see the out beautiful when we talk about python we mean two separate things that are closely related Python language and a particular implementation python as a language is just a specification that defines a set of rules and grammar for writing python code a python implementation is basically a program that understands those rules and can execute python code earlier in the course we downloaded python from py python.org this is the default implementation of python called cpython It's a program written in C that's why it's called C python so here in terminal when we run python we get this C python this is the default implementation of python there are a few other implementations out there such as jython written in Java iron python written in C and piie written in a subset of python itself as new features are added to the the Python language they are first supported by cpython because that's the default implementation and then they will gradually come to the other implementations in theory if we give some python code to any of these implementations we should get the same result but in practice that's not always the case certain features may be available in one implementation but not another or they may just behave a little bit differently in a particular implementation now you might ask what is the point of this why do we have several implementations of python wouldn't C python be enough well it's for the same reason that we have multiple operating systems or multiple browsers or multiple programming languages after all these years we programmers haven't agreed on a single programming language and that's the same story with python implementations however there is one technical reason behind these implementations that you should be aware of since jyon is implemented in Java it allows you to reuse some existing Java code in a Python program so if you're a Java developer and you want to import some Java code into a Python program you should use jython instead of cpython similarly iron python is written in C so if you're a c developer and want to bring some C code into a Python program you will have to use iron python next we'll look at how exactly cpython executes python code [Music] the programming languages we use like C C Java python these are all Simple Text based languages that we humans understand computers don't understand them they only understand machine code so if we have some code written in C we should convert it to machine code and that's the job of a c compiler so a c compiler is a program that knows how to convert or compile C code into machine code however this machine code is specific to the type of CPU of a computer so if we compile a c program on a Windows machine we can't execute it on a Mac because Windows and Mac have different machine code just like how people from different countries speak different languages Java came to solve this problem Java compiler doesn't compile Java code into machine code instead it compiles it into a portable language called jav Java bite code which is not specific to a hardware platform like Windows or Mac now we still need to convert Java bite code to machine code so Java also comes with a program called Java virtual machine or jvm for doing this when we run a Java program jvm kicks in it loads our Java bite code and then at runtime it will convert each instruction to machine code with this model we can run Java bite code on any platforms that have a jvm we have jvm implementations for Windows Mac and so on so the jvm implementation on Windows knows how to convert Java bite code into machine code that a Windows machine can understand C and python have also taken the same route so they are platform independent when we run a Python program using cpython first it will compile our python code into python bite code then it will pass that bite code to python virtual machine which will in turn convert it into machine code and execute it this is how cpython works in the last lecture we talked about various python implementations I told you that if you want to reuse some Java code in a Python program you should use jython now let's see how jython makes this possible when you use jython to run a Python program instead of compiling your python code into python by code it will compile it to Java by code so we can take this Java bite code and run it using Java virtual machine and that's why you can import some Java code into a Python program when using jython because the end result is Java bite code which will eventually be executed by Java virtual [Music] machine so I've got a few questions for you cuz I want to see if you have been really paying attention to this video or not you better have so here's the first question for for each question I want you to pause the video think about the answer for a few seconds when you're ready continue watching so here's the first question what is an expression an expression is a piece of code that produces a value here's an example of an expression what do you think is the value of this expression well here we have this string we're multiplying this by three so the result will be a string of three asterisk like this here's another question what is a syntax error a syntax error is a kind of error that is due to bad syntax or bad grammar in the code and finally the last question what does a linter do a linter is a tool that checks our code for potential errors mostly in the category of syntactical Errors so if you have grammatical issues in our code the linter will tell us before running our program okay okay that's it for now if you like more quizzes and programming exercises look at the link below this video and if you have enjoyed this video I hope you have please support me by giving a thumbs up please like this video and share it with others in the next section we're going to look at the fundamentals of [Music] python hey guys I just wanted to let you know that this tutorial is actually the first two hours of my complete python Mastery course if you're finding this helpful and want to dive even deeper the the full course covers everything from beginner Basics to advanced concepts like machine learning web development and automation you'll also get Hands-On projects to build your skills step by step I put the link in the description box if you're ready to take your python knowledge to the next level now let's continue let's start this section by a discussion of variables which are one of the Core Concepts in programming we use variables to store data in computer's memory here are a few examples I'm going to Define a variable called students underline count and setting it to a th000 when we run this program python interpreter will allocate some memory and store this number thousand in that memory space then it will have this variable reference that memory location so this variable is just like a label for that memory location we can use this variable or this label anywhere in our program program to get access to that memory location and the data stored there so now if we print students count and run our program we will get the number thousand so this is the basic of variables now what kind of data can we store in computer's memory well we have several different kinds of data in this section we're going to look at the built-in primitive types in Python primitive types can be numbers booleans and strings let me show you so here we have a whole number we refer to this as an integer in programming we can also have numbers with a decimal point let's take a look so rating we set this to 4.99 this is what we call a float or a floating Point number and this terminology is not specific to python in the future when you learn a new programming language you're going to hear these terms again now let's take a look at an example of a Boolean is published we set this to true or false these are examples of Boolean values in programming so Boolean values can either be true or false and these are exactly like yes and no in English later in the course you will learn that we'll use these Boolean values to make decisions in our programs for example if the user is an admin user perhaps we want to give them extra permissions so these are the Boolean values now take into account that python is a case sensitive language which means lowercase and uppercase characters have different meanings so Boolean values should always start with a capital letter like what you see here if we type false or false these are not accepted Boolean values in Python only what you see here is a valid Boolean value so false or true and finally let's take a look at an example of a string so of course underline name we set this to a string like Python Programming so a string as I told you before is like text whenever you want to work with text in your programs you need to surround your text with quotes so these are the basics of variables so these are the variables from the last lecture now I've got a question for you there are four things that I've consistently used in this program can you spot them if you want you can pause the video think about this for a few seconds and then continue watching so here are those four things the first thing is that all my variable names are descriptive and meaningful so students count represents the number of students for a course or course name clearly explains that this variable holds the name of a course one of the issues that I see a lot amongst beginner programmers is that they use mystical names for their variables something like this CN as in short for course name when someone else reads this code they have no idea what CN stands for or they use variable names like C1 when I look at that code I wonder where is C2 and what is the difference between C1 and C2 so these variable names are very mystical that's a bad practice make sure your variable names are always descriptive and meaningful because this makes your code more maintainable now there are times that you can use short variable names like x y z if you're dealing with things like coordinates so that's an exception now the second thing that I have consistently used in this code is that I have used lowercase letters to name my variables so here we don't have course name all in capital or in title case all letter are lowercase right let's delete this the third thing that I've consistently used here is that I have used an underscore to separate multiple words and I've done this to make my variable names more readable because in Python we cannot have a space in variable names so we cannot have course name and if you put these two words together it's a little bit hard to read that's why we use an underscore and the fourth thing that I have used consistently here is that I have put a space around this equal sign again that's one of the issues I see a lot amongst beginners they write code like this this is a little bit ugly this is what we call Dirty code dirty stinky smelly you should write code that is clean and beautiful so other people can read it like a story like a newspaper article it should be formatted properly and that's why we have pep 8 in Python now the good thing is if you forget these rules when you save the changes autopep8 kicks in and it automatically reformats your code but that aside you should always give yourself the habit of writing clean code without relying too much on the tooling so these are all the best practices about naming your variables next we're going to look at strings in more detail so here we have this course variable set to Python Programming as I told you before whenever you work with text you should surround your text with quotes you can either use double quotes or single quotes that's more of a personal preference but quite often we use double quotes we also have triple quotes and we use them to format a long string for example if you have let's say a variable message that is the message we want to include in the body of an email you can use triple quotes to format it like this hi John this is msh from code with m.com blah blah blah so that's when we use triple codes now we don't need this in this lecture so delete let me show you a few useful things you can do with strings first of all we have this built-in function in Python for getting the length of strings what is a function a function is basically Bally a reusable piece of code that carries out a task as a metaphor think of the remote control of your TV on this remote control you have buttons for different functions like turn on turn off change the channel and so on these are the built-in functions in your TV in Python and many other programming languages we have the exact same concept so we have functions that are built into the language on the platform you can reuse these functions to perform various tasks so here we can use the built-in Len function to get the length of a string which means the number of characters in that string now whenever you want to use a function you should use parenthesis now we say we're calling this function which basically means we're using this function now some functions take additional data which we refer to as arguments these arguments are inputs to these functions so this Len function takes an input or an argument here we pass our course variable and this will return the number of characters in this string so let's print that and see what we get run the program we get 18 because we have 18 characters here let's look at another example if you want to get access to a specific character in this string you use the square bracket notation so here we add course square bracket brackets to get the first character you use the index zero so in Python like many other languages strings are zero index which means the index of the first character or the first element is zero so now when we print this we'll get P okay now you can also use a negative index like minus1 what does that mean well if zero represents the first character here what do you think negative 1 represents that takes us back to the end of the string so that Returns the first character from the end of the string let's draun this program you will see we'll get G there you go using a similar syntax you can slice strings let me show you so I'm going to duplicate this line and remove ne1 now let's say we want to extract the first three characters in this string so here we need two indexes the start index colon the end index so this will return a new string that contains the first three characters in this course variable that would be P Y and T so the index of these characters are zero 1 and two so that means the character at the end index is not included okay let's run the program and make sure we get the right result there you go PYT now what if we don't include the end index what do you think we're going to get it's Common Sense we start from index zero and go all the way to the end of the string so this will return a new string that is exactly the same as the original string let's take a look so we get Python programming now what if we don't include the start index but include the end index what do you think we're going to get once again it's common sense so by default python will put zero here so it will start from the beginning of the string so when I run this program we should get PYT one more time there you go and finally as the last example if we don't include the start and the end Index this will return a copy of of the original string let's look at this so we get Python Programming now you don't have to memorize any of these just remember we use the Len function to get the length of a string we use bracket notation to get access to a specific element or a specific character and we use this notation to slice a string so we have this string here python Pro programming now let's say we want to put a double quote in the middle of this string there is a problem here python interpreter sees this second string as the end of the string so the rest of the code is meaningless and invalid how do we solve this problem well there are two ways one way is to use single Cotes for our string and then we can use a double code in the middle of the string but what if for whatever reason perhaps for being consistent in our code we decided to use double quotes how can we add another double code in the middle of this string well we can prefix this with a backs slash backslash in Python strings is a special character we have a jargon for that called Escape character we use it to escape the character after let me show you what I mean so let's let's print this course and run this program what's going on here we don't have the backs slash because we use that to escape this double code and basically display it here so backs slash is an escape character and back SL double quote is an escape sequence in Python strings we have a few other Escape sequences that you should be aware of let me show you so in Python we use a hash sign to indicate a comment a comment is like additional note that we add to our program it's not executed by python interpreter okay so here are the Escape sequences you have seen back SL double quote we also have back SL single code so we can use that to add a single code here let's run the program here it is beautiful we also have double backs slash so if you want to include a backslash in your strings you should prefix it with another backslash let me show you so when we run this we get python one back slash programming and finally we have back sln which is short for new line so now if I add a back slash n here see what we get we get a new line after python so programming will end up on the second line so these are the Escape sequences in Python here we have two variables first and last let's say we want to print my full name on the console so we can Define another variable full set it to first then concatenate it with a space and one more time concatenate it with last now when we print full we get my full name on the console beautiful now this approach of using concatenation to build a string is okay but there is a better and newer approach we can use formatted strings so here we can set full to this string and prefix it with an F which can be lowercase or uppercase this formatted string doesn't have a constant value like these two strings here It's actually an expression that will be evaluated at runtime so here we want to add our first name we use curly braces to print the value of the first variable after that we add a space and then we add curly braces one more time to print the last name so at run time this expression will be evaluated what we have in between curly braces will be replaced at runtime now let's run this program one more time we get the exact same result just be aware that you can put any valid expressions in between curly braces so earlier you learned about the built-in Len function we can call Len here to get the length of this string let's run this program one more time so we get four we can also replace last with an expression like this 2 + 2 let's run this program we get four and four so when using formatted strings you can put any valid expressions in between curly braces in this lecture we're going to look at a few useful functions available to work with strings so earlier you learned about this builtin Len function this function is general purpose so it's not limited to Strings later I will show you how to use this function with other kind of objects but in Python we have quite a few functions that are specific to a strings let me show you so here if we type course dot see all these are functions available on strings now in precise terms we refer to these functions as methods this is a term in object-oriented programming that you will learn about later in the course for now now what I want you to take away is that everything in Python is an object and objects have functions we call methods that we can access using the dot notation so here course is an object we use the dot notation to access its functions or more accurately methods let's take a look at a few of these methods we have upper to convert a string to uppercase now let's print this and run the program here's what we get beautiful now note that the methods that you call here return a new string so the original string is not affected let me show you so print course run the program one more time look this is our original string right so course. upper returns a new string a new value we can store it in a variable like course underline Capital like this now to keep this demo simple and consistent I'm going to revert this back and use a print statement we also have the lower method to convert a string to lowercase we also have title which will capitalize the first letter of every word so if our string was like this when we call the title method we get Python Programming as you see here okay another useful method is strip and we use it to trim any white space at the beginning or end of a string this is particularly useful when we receive input from the user let me show you so let's imagine the user entered a couple of white spaces at the beginning of this string when we call course. strip those white spaces will be removed take a look so note that in the first three examples we have the those white spaces but in the last one it is removed so a strip removes the white space from both the beginning and end of a string we also have l strip which is short for left strip and R strip which is short for Right strip so it will remove the white space from the end of a string if you want to get the index of a character or a sequence of characters in your string you should use the find method and me show you so of course find so as an argument here we pass another string we can pass a character or a series of characters let's find the index of Pro run the program so the index of pro is nine so if we start from zero here all the way to nine this is the index of pro okay now as I told you before python is a case sensitive language so if I pass a capital P here obviously we don't have these exact characters in our string so let's see what we get we get -1 that means this string was not found in the original string another useful method is replace so we call replace with this we can replace a character or a sequence of characters with something else so let's say we want to replace all lowercase P's with J with this we get jython durog gramming whatever that means and finally if you want to check for the existence of a character or a sequence of characters in your string you can use the in Operator Let Me Show You So print we write an expression like this Pro in course so this is an expression as I told you before an expression is a piece of code that produces a value so this expression checks to see if we have Pro in course the difference between this expression and calling the fine method is that the fine method Returns the index of these characters in our string but as this expression returns a Boolean so it's a true or false let me show you so run the program we get the Boolean true and finally we have the not operator and we use that to see if our string does not contain a character or a sequence of characters so let's change this to Swift not in course when this expression is evaluated what do you think we're going to get well we don't have Swift in this string so not in will return true let's take a look there you go go so these are the useful string Methods next we'll look at numbers in Python we have three types of numbers two of these you have already seen before they are integers and floats we also have complex numbers so complex numbers in math are in the form a plus b i where I is the imaginary number number now if you're not familiar with this concept don't worry this is something that is used a lot in mathematics and electrical engineering if you want to use Python to build web applications you're never going to use complex numbers but let me quickly show you the Syntax for representing complex numbers instead of I we use J so here is an example 1 + 2 J so X now is a complex number and by the way as I told you before this is just a common or an additional note in our program when we run this program anything after this H sign will be ignored so these are the three types of numbers we have in Python for all these types of numbers we have the standard arithmetic operations that we have in math let me show you so we have addition subtraction multiplication division but we actually have two different types of divisions let me show you first let's run this program so with this division operator which is a slash we get a floating Point number if you want an integer you use double slashes let me show you so double slash run the program we get three okay we also have modulus which is the remainder of a division and finally exponent Which is less left to the power of right so 10 to the power of 3 will be a th000 these are the standard arithmetic operators now for all these operators we have a special operator called augmented assignment operator let me show you so let's imagine we have X set to 10 we want to increment X by let's say three we can write an expression like this x = x + 3 or we can use an augmented assignment operator that is a little bit shorter so we write X+ equal three these two statements are exactly the same now here I'm using addition as an example you can use any of these operators here next I'm going to show you some useful functions to work with numbers in this lecture we're going to look at a few few useful functions to work with numbers so we have this built-in function round for rounding a number so if we pass 2.9 here and print the result we will get three we have another useful built-in function called ABS which Returns the absolute value of a number so if we pass -2.9 here we'll get positive 2.9 now teic we have only a handful of built-in functions to work with numbers if you want to write a program that involves complex mathematical calculations you need to use the math module a module is like a separate file with some python code so in Python we have this math module which includes lots of mathematical functions for working with numbers but we need to import this module so we can use it on the top we type import math now math in this program is an object so we can use the dot notation to see all the functions or more accurately all the methods available in this object as an example we have math. seal for getting the ceiling of a number so if we pass 2.2 here and run this program we get three now in this math module we have lots of functions let me show you how to find the complete list here on Google search for Python 3 make sure to add the version number math module on this page you can see all the functions in the math module so in this lecture we looked at math. seal we also have math. copy sign Fabs and so on as an exercise I encourage you to play with a couple of functions in this module all right now let's take a look at another useful built-in function in Python we use the input function to get input from the user as an argument we pass a string this will be a label that will be displayed in the terminal you'll see that in a second so let's add X colon now this function returns a string so we can store it in this variable now let's imagine that y should be x + 1 save the changes now don't run this program using the code Runner extension because code Runner by default runs your program in the output window which is read only so you won't be able to enter a value so open up the terminal using control and backspace once again if you're on Windows type python if you're on Mac or Linux Linux type Python 3 and then app.py so here's our label let's enter a value like one we got an error type error what is going on here well when we receive input from the user this input always comes as a string so this expression at runtime will look like this string 1 + 1 note that the number one is different from string one because these are two different types now when python sees this expression it doesn't know what to do because two objects can be concatenated if they are of the same type so here we need to convert this string one to a number in Python we have a few built-in functions for type conversion we have int for converting a number to an integer we have float we have bull and stir or string now in this case we don't need to convert X to a string because X is already a string if you don't believe me let me show you so I'm going to comment out these few lines now let's print type of X so type is another built-in function we pass an object as an argument and it returns its type also I'm going to comment out this line because that's the bad boy we don't want to execute this save the changes back in the terminal let's run this program one more time enter one look this is what the type function returns now don't worry about the class we'll talk about classes later in the course so the type of X is a stir or string so let's delete this line to fix this problem we need to convert X to an integer and then we can print both X and Y using a format of string remember so we add an F quotes right here we add a label like X then we'll add a field so here we want to print the value of x variable after that we add some more text and finally we want to print the value of y let's run this program one more time so here in the terminal let's enter one and here's the result X is one and Y is two beautiful now all these built-in functions are self-explanatory the only tricky one is bull because in Python we have this concept of truthy and falsey values these are values that are not exactly a Boolean true or false but they can be interpreted as a Boolean true or false so here are the falsy values in Python M2 strings are considered falsy so they're interpreted as a Boolean false numbers Z is also falsy we have an object called non which represents the absence of a value we'll look at this later in the course so whenever we use these values in a boan context we get false anything else will be true let me show you a few examples so in this interactive shell in Python let's convert number zero to Bull that's falsy so we get false what about bull of one we get true if we pass a negative number we also get true if we pass a number larger than one like five we still get true so we only get false when we try to convert zero to aoia now with strings I told you that an empty string is falsey so here we'll get false anything else is true so even if I have a string that is false we'll get true because the this is not an empty string it's a string with a few characters that's why it's evaluated as true all right once again it's time for another quiz let's see if you have been really paying attention to this tutorial so here's the first question what are the built-in primitive types in Python we have strings numbers and booleans numbers can can be integers Floats or complex numbers here's the second question you have this variable fruit set to Apple what do you think we will see on the terminal when we print fruit of one well using screw brackets we can access individual characters the index of the first character is zero so this expression Returns the second character which is p what if we add a colon and negative one here well using the syntax we can slice a string our start index is one and our end index is negative -1 which refers to the first character from the end of the string now when slicing a string the character at the end index or1 is not included so with this expression we'll get all the characters starting from the second character which is p all the way until we get to e so the result of this expression is PPL L here's another question what is the result of this expression well this is what we call the modulus operator and it Returns the remainder of a division which is in this case one and finally the last question what do you think we will see when we print bull of false well earlier I told you about falsy values in Python so number zero an mty string and the non-ob these are all falsy values anything that is not falsey is considered truthy here we have a string that has five characters it doesn't matter what those characters are this is not an empty string so it's not falsey it's truy so when we convert it using the bull function we'll get the Boolean true and this brings us to the end of the section in the next section you're going to learn the fundamentals of computer programming I hope you have enjoyed this section and thank you for watching we're going to start this section by exploring comparison operators we use comparison operators to compare values here are a few examples so 10 is greater than three we get true so what we have here is a Boolean expression because when this expression is evaluated we'll get a Boolean value that is true or false here is another example 10 is greater than or equal to three once again we get true we also have less than so 10 is less than 20 we have less than or equal to here's the equality operator so 10 is equal to 10 what about this expression what do you think we're going to get we get false because this values have different types and they're stored differently in the computer's memory and finally we have the not equal operator so now with this expression we should get true beautiful we can also use these comparison operators with strings let me show you so we can check to see if bag is greater than and apple we get true because when we sort these two words bag comes after so it's considered greater now what about this one bag equals Capital bag we get false here's the reason every character you see here has a numeric representation in programming let me show you so we have this built-in function called or don't worry about memorizing this because you're probably never going to use this in the future but let me show you the numeric representation of the letter B so that is 98 in contrast capital B is represented as 66 that is the reason these two strings are not equal so these are the comparison operators in Python next we'll look at conditional statements in almost every program there are times you need to make decisions and that's when you use use an if statement here's an example let's say we have a variable called temperature we set it to 35 now if temperature is greater than 30 perhaps we want to display a message to the user so we use an if statement if after if we add a condition which is basically a Boolean expression an expression that produces a Boolean value so if temperature is greater than 30 here we have a Boolean expression if this expression evaluates to true the following statements will be executed let me show you now here's the important part that a lot of beginners miss when you use an if statement you should always terminate your statement with a colon now let's see what happens when I press enter our cursor is indented so here we have two white spaces this is very important because using these indentations python interpreter will know what statements should be executed if this condition is true here we want to print a message like it's warm we can print another message as well drink water so we can have as many statements as we want here as long as they are indented they belong to this if block now when we finish here we should remove indentation to indicate the end of this if block so here we can add a print statement with a message like Don this statement will always be executed whether this condition is true or not now note that when I save the changes this indentation you see here is going to be doubled up take a look save there you go so when we save the changes autop pep 8 reformats our code and uses four white spaces for indentation so one 2 3 4 it uses four white spaces because that's what pep 8 recommends all right now let's run this program so because temperature is greater than 30 we see the first two messages and we see the dawn message regardless so if I change the temperature to let's say 15 and run the program one more time look this Dawn message is executed whether our condition is true or not so pay great attention to these indentations that's one of the issues I see in beginner's code let's say they want both these print statements to be executed if the condition is true accidentally they remove the indentation on the fourth line and that's why their program doesn't work as they expect so be careful about this now what if you want to have multiple conditions we use an L if statement so L if that is short for L's if here we can add another condition another expression so temperature is greater than 20 one once again colon enter now by default here vs code is using two white spaces so don't worry about this as soon as you save the changes those two white spaces will be converted to four white spaces so let's print a different message it's nice save the changes now look all these lines are indented consistently you can have as many l statements as you want and optionally you can also have an else statement so if none of the previous conditions are true then what you have in the else block will be executed once again we add the colon annotation print here we can add a message like it's called save the changes in this case temperature is 15 so none of these two conditions will be true and we will see it's called let's run the program there you go in this lecture I'm going to show you a technique for writing cleaner code so let's say we're building an application for University and we want to check to see if the person who's applying for this University program is eligible or not so we start by defining a variable called age set it to 22 now if age is greater than or equal to 18 colon print eligible remove the initation else colon print not eligible let's run the program make sure it works beautiful now there is nothing wrong in this piece of code but I want to show you a cleaner way to achieve the same result instead of having a print statement here we can define a variable like message and set it to this string that is the first step so message equals this string and then we will print this message now when you have an if L statement with this structure where you're basically assigning a value to a variable you can rewrite this in a simpler way so this is how it works all we want to do over these VI lines is to assign a value to this message variable right so with start with message we set it to eligible if age is greater than or equal to 18 else we set it to not eligible this statement is almost like plain English so what we have on line seven is exactly equivalent to these four lines of code delete save the changes run the program you can see this person is eligible if I change the age to 12 12 and run the program we get not eligible so what we have here is called Turner operator in Python we have three logical operators and we use these operators to model more complex conditions so these operators are and or and not let's see a real word example of using these operators so imagine we're building an application for processing loans so we need two variables High income we can set this to true and good underlined credit we set it to true now here's the condition we want to implement if the applicant has high income and good credit score then they are eligible for the loan so if High income and good credit we add the colon and print eligible now note that here I have not compared the value of this variable with true that is one of the issues I see in a lot of beginners code this is redundant and unprofessional because High income is a Boolean so it's either true or false we don't need to compare true with true so if this condition is true and this second condition is true then we will print eligible in the terminal so save the changes and run the program obviously this person is eligible however if one of these conditions is false we will not see eligible in the terminal so let's add an lse statement here and print not eligible run the program we see not eligible so this is how the and operator works with and operator if both conditions are true the result will be true in contrast with the or operator as long as at least one of the conditions is true the result will be true so if I replace and with or here we should see eligible in the terminal let's run it one more time there you go so these are the and and or operators now let's take a look at an example of the not operator so I'm going to Define another variable student set it to True temporarily I'm going to remove this expression and simplify it we'll come back to this later so let's say if the person is eligible if they are not a student the not operator basically inverses the value of a Boolean so in this case student is true when we apply the not operator the result will be false so in this case our condition will be false and that's why this print statement will not not be executed let me show you so save run the program they're not eligible if student was false when we apply the not operator will get true so our condition will be true and we'll see eligible let's run it one more time there you go with these operators we can model even more complex conditions here's an example a person can be eligible if they have either High income or good CR credit and they should not be a student let me show you how to implement this condition so if High income or good credit we want at least one of these conditions to be true so we put these in parenthesis we want to separate these from the other condition which is not a student now the result of this should be true which means at least one of these conditions should be true after that will add and not student and finally call so with these operators you can model all kinds of real word scenarios so here's the example from the last lecture a person is eligible for a loan if they have high income and good credit and they're not a student now one thing you need to know about this Boolean operator is that they are short circuit what do I mean by that well when python interpreter wants to evaluate this expression it starts from the first argument if this is true it continues the evaluation to see if the second argument is also true so it continues the evaluation all the way to the end of this expression however as soon as one of these arguments is false the evaluation stops let me show you what I mean so if I change High income to false when python interpreter sees this expression it starts here it knows that high income is false so it doesn't matter what comes after the result of this entire expression will always be false because at least one of the arguments or one of the operant is false this is what we call short circuiting just like the short circuit concept we have in electronics so the evaluation stops as as soon as one of these arguments evaluates to false we have the same concept with the or operator so if I change these and operators to or let's see what happens with the or operator we know that at least one of the arguments should be true so the evaluation stops as soon as we find an argument that evaluates to true in this case when python interpreter evaluates this expression it sees that high income is false so so it continues the evaluation hoping that the next argument will be true here good credit is true so evaluation stops and the result of this entire expression will be true so in Python logical operators are short circuit in this lecture I'm going to show you how to chain comparison operators this is a very powerful technique for writing clean code here's an example let's say we want to implement a rule that says age should be between 18 and 65 here's how we can implement it so we Define a variable like AG set it to 22 now if age is greater than or equal to 18 and age is less than 65 then we print eligible now here's a question for you how do we write this rule in math we can write it like this well more accurately we should have an equal sign here so age should be between 18 and 65 this is how we write this rule in math now I've got some good news for you we can write the exact same expression in Python so I'm going to move this up put an if statement here line four and line three are exactly equivalent but as you can see line four is cleaner and easier to read so let's get rid of line three this is what we call chaining comparison operators all right here's a little quiz for you I want you to pause the video and think about this quiz for 10 to 20 seconds what do you think we'll see on the terminal when we run this program so pause the video figure out the answer when you're ready come back continue watching all right let's see what happens when we run this program first we get this if statement in this case we're comparing two different objects for equality and these objects have different types we have a number compared with a string so number 10 and string 10 are not equal that is why a will not be printed on the terminal so the control moves to the L If part here we have two Boolean Expressions here's the first one here's the second one and they are combined using the logical end so if both these expressions are evaluated to true then this entire expression will be true and we will see be on the terminal let's see if both these expressions are evaluated to True here's the first part bag is greater than Apple that is true because when we sort these words bag comes after Apple but look at the second part part this expression is evaluated to false because bag is not greater than cat so when we apply The Logical end between true and false the result will be false that is why this statement will not be executed so to control moves to the lse part and when we run this program the letter c will be printed on the terminal there are times that we may want to repeat a task a number of times for example let's say we send a message to a user if that message cannot be delivered perhaps we want to retry three times now for Simplicity let's imagine this print statement is equivalent to sending a message in a real world program to send a message to a user we have to write five to 10 lines of code now if you want to retry three times we don't want to repeat all that code that is ugly that's when we use a loop we use Loops to create repetition so here is how it works we start with four number in we have a built-in function called range now how many times we want to repeat this task let's say three times so we call range and pass three as an argument now similar to our if statements we need to terminate this line with a colon enter we get indentation so in this block we can write all this statements that should be repeated three times let's do a print a message like attempt save the changes run the program so we have attempt printed three times beautiful now what is this number let's take a look it's a variable of type integer so let's pass it as the second argument to the print function number run the program this is what we get 012 so here we have a for Loop this for Loop is executed three times in each iteration number will have a different value initially it will be zero in the second iteration it will be one and finally in the last iteration it will be two now here we can do something fun we can add one to this around the program and now the messages that we print are kind of more meaningful or more user friendly like attempting number one attempting number two and so on we can take this to the next level so we can pass another argument here I'm going to add an expression one more time number + one so we'll get 1 2 3 now I want to put this expression in parenthesis so let's select this put it in parenthesis and then multiply it by a DOT so here we have a string that is multiplied by a number the result will be that string repeated that number of times let's take a look so run the program see that's pretty cool isn't it now let me show you one more thing before we finish this lecture as you saw this range function generates numbers starting from zero all the way up to this number here but it doesn't include this number here we can pass another argument say start from one and finish before four with this change we don't need to add one to number every time because in the first ation this number variable will be set to one so we can simplify our code and make it cleaner let's run it one more time we get the exact same result we can also pass a third argument as a step so I'm going to change the second argument to 10 and pass two as a step look at the result these are the numbers we get 1 3 5 and so on so pretty useful you're going to use this function a lot in real world application continuing with the example from the last lecture let's imagine the scenario where after the first attempt we can successfully send the message in that case we want to jump out of this Loop we don't want to repeat this task of sending a message three times let me show you how to implement this so in this demo I'm going to simulate the scenario where we can successfully send a message so we Define a variable successful and set it to true now here after this print statement we'll have an if statement if successful colon then perhaps we can print successful now here we want to jump out of this Loop for that we use the Breck statement let's trun this program and see what happens so there you go after the first attempt you're successful and there are no more attempts so once again I want you to pay great attention to the indentation here because that's one of the common issues amongst beginners so here's our for Loop these two lines are indented with four spaces and they belong to our for Loop in every iteration these two lines will be executed now when we get to line four if this condition is true then these two lines will be executed because both these lines are indented below this if statement now let's take this program to the next level what if we attempt three times and we still cannot send an email perhaps we want to display a different message to the user we say hey we Tred three times but it didn't work so I'm going to change successful to false now at the end here we can add an L statement this is what we call a for l statement what we put under this L statement will only be executed if this Loop completes without an early termination so if we never break out of this Loop then the L statement will be executed so here we can print a message like attempted three times and failed so run the program see what we get three attempts followed by this message attempted three times and failed in contrast if we change successful to true because we terminate this Loop using this break statement what we have in the else block will not be executed take a look R the program we have one attempt successful done in programming we have this concept called nested Loops so we can put one Loop inside of another loop and with this we can get some interesting results let me show you so I'm going to start with this Loop for X in range five colon now inside of this Loop I'm going to add another loop so for y in range three colon and then in our second Loop I'm going to add a print statement here we can use formatted strings to display coordinates remember formatted strings so we have F followed by quotes now here we add parentheses for our coordinates first we want to display X and then comma followed by y let's run this program and see what happens there you go pretty cool isn't it so we get zero and zero 0o and one zero and two then we get one and zero one and one one and two and so on now let me explain how exactly python interpreter executes this code so here we have two Loops this is what we call the outer loop and this is the inner loop so the execution of our program starts here in the first iteration of this Loop X is zero now we get to this statement which is a child of this four statement because it's indented four times this statement itself is a loop so what we have inside of this Loop will be executed three times in the first iteration X is zero because we're still in the first iteration of the outer loop and Y is also zero because we are in the first iteration of the inner loop that is why we get zero and zero now we go to the second iteration of this Inner Loop in this iteration y will be one whereas X is still zero that is why we get 0 and one and similarly in the third iteration of our inner loop we'll get zero and two in the terminal now we're done with the execution of the inner loop so the control moves back to our outer loop here will be in the second iteration so X will be one and then we start here again so we have to execute this inner loop three times in the first iteration y will be zero and X is one so here we have one and zero then we'll get one and one and one and two you got the point so this is all about nested Loops so you have learned how to use for Loops to repeat one or more statements in your programs now let's dive deeper and see what this range function returns so earlier you learned about the built-in type function with this function we can get the type of an object so if I pass Five here and run this program this is what we get so the type of this number or this object is int or integer now let's look at the type of the value that we get from the range function so as an argument we pass range of a number let's run this program so this range function returns an object of type range so in Python we have primitive types like numbers strings and booleans but we also have complex types range is an example of one of those complex types throughout this course you're going to learn about a lot of other complex types now what is interesting about this range object is that it's iterable which means we can iterate over it or use it in a for Loop that is why we can write code like this so This range function returns a range object which is iterable which means we can iterate over it in each iteration X will have a different value now range objects are not the only iterable objects in Python strings are also iterable so here we can add a string like python now in each iteration X will hold one character in this string let me show you so print X and I'm going to delete these two lines here let's run this program so in each iteration we'll get one character and print it we have another complex type called list which we use to store a list of objects so we add square brackets this indicates a list now we can add a list of numbers or a list of strings like a list of names you will learn about lists later in the course so let's run this one more time as you can see we can iterate over lists in in each iteration will get one object in this list now later in the course I will show you how to create your own custom objects that are iterable for example you will learn how to write code like this for item in shopping cart print item so shopping cart is going to be a custom object that you will create it's not going to be an integer or string or Boolean it's a custom object it has a different structure and we'll make it iterable so we can use it in a for Loop and in each iteration we can get one item in the shopping cart and printed on a terminal so you have learned that we use four Loops to iterate over iterable objects in Python we have another kind of loop that is a while loop and we use that to repeat something as long as a condition is true here's an example so let's define a variable number and set it to a 100 now we use while and here we add a condition as long as number is greater than zero we add a colon once again we have indentation so we can repeat one or more statements we can print this number and then we can divide it by half so number equals number use the integer division to divide it by two or we can use the augmented assignment operator to shorten this code like this now let's run this program so here's what we get initially our number is 100 we divide it by half we get 50 then 25 and so on so as you can see in this example we are not iterating over an itable like a range object or a string or a list we are evaluating a condition and repeating a task let me show you a real word example of a y Loop in this interactive shell python is waiting for an input we can type something like 2 + 2 it will evaluate it and ask for the next input we can add another expression like 10 is greater than two so these steps will continue until we press contrl D so behind the scene we have a y Loop that continues execution until we press contr D that is the condition that causes the Y Loop to terminate let me show you how to build something like this in Python so let's Define a variable command and set it to an empty string now here we need a y Loop we want this y Loop to execute as long as command does not equal to quit so command does not equal to quit colon in this Loop we want to continue continuously get input from the user so we use the built-in input function we add a label like this get the result and store it in the command variable now at this point python interactive shell will evaluate this command we're not going to do that in this lecture because that's way too complex for Simplicity we can just Echo back what the user entered so print Echo and as the second argument we as this command so this is our y Loop it will execute until we type quit now as I told you before don't run this program using the code Runner extension because by default it will run your program in the output window which is read only so open up the terminal using control and back tick and run python or Python 3 app.py so here's our Command Prompt let's type 2+ two it echoes back let's type 3 * 2 there you go if we type quit our program terminates now let's try it one more time what if we type quit in uppercase the program doesn't terminate because as you learned before lowercase and uppercase characters have different numeric representations so quit in lowercase is different from quit in uppercase now to solve this problem an amateur programmer may do something like this and command does not equal to Capital quit so while command does not equal quit in lowercase and quit in uppercase continue getting input from the user let's run this program in terminal and see what happens so one more time python app.py we type quit beautiful it works we type quit in uppercase that would work too but what if I type quit with an uppercase q and lowercase U our program doesn't terminate so this is a poor way of checking for the quit command what is a better way let me show you so we don't need this end operator here instead because command is a string we can call the lower method so whatever the user types in first will'll convert it to lowercase and then compare it with quit in lowercase with this change it doesn't matter how the user types the word quit will always terminate the program now the last thing I want to discuss in this section is the concept of infinite Loops an infinite Loop is a loop that runs forever so if I change this condition to true because true is always true this y Loop will will run forever so to jump out of this we need a break statement so after we get the input from the user we can get the command convert it to lowercase and see if it equals to quit if that's the case we want to break now with this change we no longer need to initialize command to an empty string previously we needed this because we had a while statement like this while command does not equal will quit so we had to Define this command variable and that's why we have set it to an empty string without this line when python interpreter tries to execute this code it doesn't know what command is so now that we have an infinite Loop we no longer need to Define command and set it to an empty string so in terms of functionality this program is exactly the same as the program we wrote in the last lecture just be aware of these infinite Loops because they run for ever you should always have a way to jump out of them otherwise your program will run forever and this can sometimes cause issues because if you're executing operations that consume memory at some point your program may run out of memory and crash all right time for an exercise I want you to write a program to display the even numbers between 1 to 10 so when you run this program you should see 2 4 6 and 8 and after these I want you to print this message we have four even numbers now here's a quick hint before you get started you should call the range function with one and 10 do not use the third argument which is called Step so basically I want you to iterate over all the numbers between 1 to 10 check if each number is an even number and then print it on the terminal so pause the video spend 2 minutes on this exercise when you're done come back continue watching so we start with a for Loop for number in range 1 to 10 colon we check to see if the remainder of division of this number by two equal Z so if number modulus 2 equal Z then reprint this number now let's run this program so we get 2 4 6 8 beautiful now to count the even numbers we need a separate variable so let's call that count initially we set it to zero now in this if block every time we find an even number we need to increment count so we said count plus equals 1 and finally after our for Loop we can print a formatted string we have count count even numbers let's run the program and here's the result so that brings us to the end of this section in the next section you're going to learn how to create your own functions I hope you enjoyed the section and thank you for watching so far you have learned how to use some of the built-in functions in Python such as print round and so on in this section you're going to learn how to write your own functions now you might ask but why do we even need to write our own functions well when you build a real program that program is going to consist hundreds or thousands of lines of code you shouldn't write all that code in one file like we have done so far you should break that code into a smaller more maintainable and potentially more reusable chunks you refer to these chunks as functions so let me show you how to create your own custom functions we start with the defa keyword which is short for Define next we need to give our function a name so let's call this greet all the best practices you learn about naming your variables also apply to naming your functions so make sure your function names are meaningful descriptive use lowercase letters to name your functions and an underscore to separate multiple words now after the name we need to add parentheses you will see why shortly and then we'll add a column now what is going to happen you know it we're going to get indentation which means the following statements will belong to this function so here I'm going to add two statements hi there and welcome aboard both these lines belong to this function because they're indented now we're done with this function we need to call it so we remove the indentation and we add two line breaks after this function this is what pep8 recommends to keep our code clean and maintainable now if you forget to add two line braks don't worry as soon as you save the changes autopep8 will automatically add these line braks for you let me show you so I'm going to remove these line braks and call this function great with parenthesis just like how we call the built-in functions now save the changes there you go so we get two line breaks after our function now let's run this program so we get these two messages on the terminal now here's a question for you what is the difference between the GRE and print functions the difference is that this print function takes an input whereas our grd function doesn't take any inputs so let me show you how to pass inputs like first name and last name to this function when defining a function in between parentheses we list our parameters so here we add two parameters like first underline name and last underline name now when calling this function we need to supply two values for those parameters we refer to them as arguments so m hamedani these are the arguments to the greed function that's one of the terms that a lot of developers out there don't know they don't know the difference between parameters and arguments a parameter is the input that you define for your function whereas an argument is the actual value for a given parameter okay now let's change line two and instead of saying hi there we can greet a person by their full name so we can convert this to a formatted string and pass two Fields here first name as well as last name save the changes run the program and this is what we get in terminal now this function is more useful we can reuse it and call it with different arguments so let's greet John Smith as well run the program so we get Hi msh hamadani and hi John Smith now note that by default all the paramet that you define for a function are required so here our greed function takes two parameters if I exclude one of these arguments and save the changes you can see we have this red underline so pilent is complaining and saying there is no value for argument last name also if we run the program we get this type error greet missing one required positional argument so let's put this back now let ler I will show you how to define optional parameters so this is the simplified version of this great function we created earlier now in programming we have two types of functions functions that perform a task and functions that calculate and return a value here are some examples both the print and GD functions are example of type one they're performing a task which is printing something on the terminal in contrast the round function is an example of a function that calculates and returns a value so the functions that you create fall into these two categories now let me show you how to rewrite this great function but in the second form so instead of printing this string on the terminal we simply return it let me show you so I'm I'm going to delete all this code Define a new function but call it get underline greeting we add the name parameter and simply return this formatted string High name that's all we have to do so we use the return statement to return a value from this function now we can call this function get underlined greeting pass a name like msh because it returns a value we can store that value in a separate variable like message now you might be curious which form of these gting functions is better well with this first implementation we loged to printing something in the terminal in the future if we want to write that message in a file or send it in an email we have to create another function so we cannot reuse this great function in other scenarios in contrast this second form is not tied to printing something on the terminal it simply returns a value now we get this value and we can do whatever we want with it we can print it on the terminal or we can use the built-in open function to write this message to a file so we can create a file like content. txt open it for writing this returns a file object and then we can call file. write message now and don't worry about these two lines later in the course I'm going to talk about working with files but what I want you to take away here is that we have this message variable and we can do whatever we want with it we can print it on the terminal write it to a file send it in an email and so on and one more thing before we finish this lecture so here's our GD function and as you can see we're simply printing a string now if we call GRE give it a name run the program we get this message hi msh but what if we put this inside of a call to the print function let's see what we get we get high M followed by nonan what is this nonan is the return value of the great function so in Python all functions by default return the non value non is an object that represents the absence of a value later in the course you're going to learn more about nonone what matters now is that all functions return non by default unless you specifically return a value so here if we return some string none will no longer be returned now I just want to clarify something earlier I told you that we have two types of functions in programming functions that carry out a task or functions that calculate and return a value so back to the code we previously had so even though this function returns nonone by default it is still classified as a function that carries out a task let's create another function we call it increment we want to use this function to increment a number by a given value so here we simply return number plus by now we can call this function like this and commment two and one this returns a value so we can store it in a variable like result and then print it on the terminal let's run the program we get three beautiful now we can simplify this code we have used this result variable only in a single place that is line six so we don't really need it so on line six we can replace result with a call to increment function like this so when python interpreter executes this code first it will call the increment function it will get the result and temporarily store it in a variable for us we don't see that variable and then it will pass that variable as an argument to the print function now if we run this program we get the exact same result beautiful now we can make this code more readable if someone else looks at line five they may not know exactly what these arguments are four we can use a keyword argument to make this code more readable so this one here is the value of this by parameter we can prefix it with the name of the parameter like this now we can read this code almost like plain English increment to by one so if you're calling a function with multiple arguments and it's not quite clear what these arguments are for you can make your code more read by using keyword arguments so here y equals 1 is a keyword argument earlier I told you that all the parameters that you define for a function are required by default in this lecture I'm going to show you how to make the by parameter optional so let's say we don't want to explicitly pass by equals 1 every time we want to call this incr function we want to use this function to increment a value by one so we remove the second argument now we need to give this parameter a default value so we set it to one now if we call this function and don't Supply the second argument this default value will be used otherwise the value that we specify here will be used let me show you so we run this program the result is three but if we pass the second AR argument here will increment two by five so we will get seven so you can see it's pretty easy to make a parameter optional just be aware that all these optional parameters should come after the required parameters in other words I cannot add another required parameter here let's call that another I cannot add that here if I save the changes you can see we get a red underline here so all the optional parameters should come after the required parameters now obviously in this case we don't need the second parameter so let's delete it there are times that you may want to create a function that takes a variable number of arguments here is an example let's define this function multiply that takes two parameters X and Y and simply returns x * y now we can call this function like this so far so good but what if you want to pass one or two more arguments here that doesn't work because our multiply function takes only two parameters to solve this problem we need to replace these two parameters with a single parameter we use a plural name here to indicate that this is a collection of arguments and then we prefix it with an asterisk this is the magical part let me show you what happens when you use an asterisk here so temporarily let's delete this line and simply print numbers let's see what we get here so run the program you can see all our arguments and they're packed in parenthesis what is this well earlier you learned about lists I briefly mentioned that you can use square bracket to create a list of objects like 2 3 4 5 now later in the course we have a comprehensive section about lists so don't worry about the details of lists and how they work but what I want you to note here is that the only difference between this list and what we have here is in the notation so we use square brackets to create lists and parentheses to create toles some people call it tles or tuples so a topple is similar to a list and that it's a collection of objects the difference is that we cannot modify this collection we cannot add a new object to this toppo once again later in the course we're going to have a comprehensive section about lists top holes and other data structures what matters now is that these topples just like lists are iterable so we can iterate over them which means we can use them in Loops let me show you so let's write for number in numbers colon let's just print one number at a time actually we don't need this line so delete and run the program so we iterate over this top hole and in each iteration we get one number and printed on the terminal so now with a simple change we can calculate the product of all these numbers all we have to do is to Define a variable like total initially we set it to one and then in each each iteration we get total and multiply it by the current number or we can rewrite this statement using an augmented assignment operator so total times equal number line five and four are exactly identical so I'm going to use LINE five because it's shorter and cleaner delete and finally we'll return the total now one of the issues I see often in beginnner code is that they don't use this indentation properly so they put the return statement here and then they wonder why their function doesn't work properly if you put the return statement here it will be part of the for Loop so it will be executed in each iteration in this case after the first iteration because of this return statement will return from this multiply function so the total will not be calculated properly we need to put this at the same level of indentation as other statements in this function so here we have our four statement we Loop over all the numbers we calculate the total and then finally return it so with this implementation we can get the result and printed on the terminal let's run the program and you can see the product of these numbers is 120 hey guys I just wanted to let you know that this tutorial is actually the first two hours of my complete python Mastery course if you're finding this helpful and want to dive even deeper the full course covers everything from beginner Basics to advanced concepts like machine learning web development and automation you'll also get Hands-On projects to build your skills step by step I put the link in the description box if you're ready to take your python knowledge to the next level"
NClmyC6olC0,in this video we're diving into the top programming languages to learn in 2025 and why they're worth your time let's Jump Right [Music] In first I want to give a quick shout out to our newest members Joe Abdul Rahim rishab Aisha Ernie Chris lizelle Yasmin Marcus and George thank you so much for joining this Channel and supporting me you're awesome by the way if you're new here welcome this channel is all about helping you build a strong foundation in coding and land your dream Tech job I create practical no fluff tutorials road maps and career advice to help you succeed if that sounds good H subscribe and check out the other videos on this channel all right let's talk about the top programming languages for 2025 first up is python it's still the king of programming languages why because it's super versatile beginner friendly and Powers some of the coolest take out there like data science machine learning web development and Automation in 2025 AI is only getting bigger and python is the go-to language for AI and machine learning process projects but here's the thing learning python isn't just about Landing your first job it's about staying relevant throughout your entire career whether you're a total beginner or a Season Pro python is one of those languages you'll keep coming back to now if you want to Learn Python I have a couple of tutorials on this channel I put the links down below I also have comprehensive courses on my website if you prefer structured learning again links are down below next up we've got Java now I know what you're thinking Java has been around forever right but it's far from outdated in fact it's still the backbone of of so many Industries banking systems Healthcare platforms e-commerce sites and so on now some people might argue that cotlin is better and yeah cotlin is awesome but Java's ecosystem tools and Community are hard to beat plus tons of companies still rely on Java for its stability and scalability and if you're into Android development Java is a solid Choice Bottom Line If you're looking for job security and opportunities at big companies you can't go wrong with Java if you want to learn Java again I have a bunch of tutorials on this channel now let's talk about JavaScript whether you love it or hate it it's everywhere seriously over 98% of websites use JavaScript it's used in front end development backend development and even mobile development now you might say msh with tools like chat GPT why even bother learning JavaScript here's the deal AI tools can definitely generate code but you still need to understand what's going on think about it would you let chat GPT write a legal contract for selling your house and just sign it without reviewing with a lawyer probably not it's the same with code you've got to review it refine it and tweak it to make sure it works for your project now if you want to take JavaScript to the next level typescript is the perfect upgrade it adds static typing which helps catch bugs early improves maintainability and makes working on bigger projects way easier I believe in 2025 more companies are going to use typescript to boost productivity and reduce bugs and here's the good news if you already know JavaScript learning typescript is a piece of cake you can probably learn it in about a month again I have a tutorial on this channel if you're interested all right let's talk about SQL it might not be FL flashy but it's one of those skills every take professional needs whether you're working with data or building software SQL is your go-to for managing databases and let's be real AI is exploding and that means the demand for data is off the charts AI runs on data and SQL is how you work with that data even if you specialize in another language knowing SQL will give you a serious Edge it's one of those must have skills in your toolkit last but definitely not least C++ yeah it's a bit tougher to learn especially if you're just starting out but there is a reason and it's still so popular C++ is all about speed and control it Powers everything from game engines to highfrequency trading systems it's huge in Industries like Automotive Robotics and real-time simulations so if you're into cutting Ed Tech C++ is worth your time and there you have it the top programming languages to learn in 2025 whether you're starting your coding Journey or leveling up your skills these languages open doors to amazing opportunities python Java JavaScript typescript cql and C++ each have unique strengths so pick the one that fits your goals now what do you think did your favorite language make the list let me know in the comments below if you found this video helpful give it a like And subscribe for more helpful videos thanks for watching
v7BNtpw53AA,let's talk about the essential skills you need to land your first cyber security job we'll look at the main areas you should study which certificates can help and how long each step might take if you can put in 3 to 5 hours of study or practice each day you can be ready for an entry level role in about 7 to 10 months let's Jump Right [Music] In first I want to give a quick shout out to our newest members Edgars Christian loveg shales Joe thank you so much for joining this Channel and supporting me you're awesome by the way if you're new here welcome this channel is all about helping you build a strong foundation in coding and land your dream Tech job I create practical no fluff tutorials road maps and career advice to help you succeed if that sounds good hit subscribe and check out the other videos on this channel the first step is building a strong foundation in it this is a step that unfortunately a lot of people skip but it's absolutely important especially if you're new to Tech or transitioning from another job if someone asks you to fix their computer computer or troubleshoot their Wi-Fi and you have no clue this is your starting point otherwise you can skip to the next step now a great place to start is CompTIA A+ it's a well-known certification that covers foundational it knowledge like installing operating systems handling common PC issues managing Essential Software and so on I'll put the link down below if you're interested if you spend 3 to 5 hours of studying every day this step should take you about a month or two by the way I'm not affiliated with CompTIA or any other companies I'm going to mention in this video I'm recommending them simply because they're wellknown and give you a solid foundation in cyber security Now assuming that you have a solid foundation in it the next step is computer networking if you really want to protect or attack systems you have to understand how data moves around so spent about a month or two learning OSI and tcpip models common protocols like HTTP https TCP and so on IP addressing and subnetting as well as basics of routers switches and firewalls if you want a structure way to learn and proove your networking skills CompTIA Network plus is a great entry level certification it covers General networking principles without focusing on one brand of devices another option is CCNA which goes deeper into Cisco's OWN Network and Equipment it's the gold standard for networking having it on your resume definitely helps you stand out but it's more difficult than Network plus by the way remember that certificates are only part of the story employers want to see real Hands-On skills not just a piece of paper so don't assume that simply getting all these certificates is going to guarantee a job immediately make sure to build those essential skills and you certificates to give your resume an extra boost now let's talk about operating systems particularly windows and Linux if you're just starting out pick one to focus on let's say windows if that's what you already use daily and get comfortable with file permissions logs and basic user management but in the long term you really should learn both because Linux is extremely common in servers Cloud environments and security tooling spend one to two months here now if you want a formal path for Linux you can go for compt Linux plus but honestly you can skip getting this certification because it's not going to help you as much as other certifications like Network Plus or CCNA if you want to get it do it for the knowledge next up is coding now you don't need to be an expert but having some knowledge of coding is going to help you a lot throughout your entire It Journey the best language for you to learn is python because it's very beginner friendly and it's super common in cyber security I have a couple of Pon tutorials on this channel one is only 1 hour long the other is more comprehensive they're super easy to follow and millions of people have already watched them to Learn Python again links are down below I would also recommend to learn bash for Linux or Powershell for Windows because these languages are also super common for automating tasks like file management user creation or system checks they're very simple and once you learn a programming language like python learning a second language will be far easier now you're ready to learn cyber security fundamentals you have a a couple of certificate options here compa Security Plus is very popular and is often a requir checkbox for many roles especially government jobs another option is Google cyber security professional certificate it's newer so some hiring managers may be less familiar with it but it's a solid path if you prefer a guided online approach now with all the foundations you have built so far next you can learn defensive security which is about defending against attacks in cyber security it's often called Blue teaming you should learn how to detect threat analyze logs and keep Network secure you have a few certificate options here the first one is Cisco cyber Ops associate it's a well-respected certificate the other option is psaa by TCM security it's a smaller brand than Cisco but it's very Hands-On the other option is ptl1 by security team blue it's laser focused on real world defensive tasks the next step is offensive security which is about testing systems or weaknesses in cyber security it's often called red teaming spend about a month or two practice scanning networks exploit vulnerabilities and simulate real world hacks you can practice with platforms like try hack me or hack the Box they provide safe labs for you to build real world hacking skills now for certifications you have a few options we have ejpt it's a Hands-On entrylevel red team certification the other option is PJP from TTM security it's another beginner level penetration testing certificate another popular option is CompTIA pentest plus so that's pretty much it if you follow follow this road map and putting 3 to 5 hours every day you can be ready for an entry-level security job in about 7 to 10 months of course everyone learns at their own pace so don't stress if you need a bit more time now if you have any questions please let me know in the comments below and I will do my best to answer you right here or in my future videos If you enjoyed this video please give it a like And subscribe for more useful content
gdiao7L9GjE,if you want to become a blockchain developer you're in the right place today I'm sharing a complete blockchain road map I'll walk you through the essential skills you need the tools I personally recommend and how much time you should spend on each assuming you dedicate 3 to 5 hours of studying every day this road map should take you about 8 to 10 months to complete let's Jump Right [Music] In first I want to give a quick shout out to our newest members Edgars Christian Bluff gien shales Joe thank you so much for joining this Channel and supporting me you're awesome by the way if you're new here welcome this channel is all about helping you build a strong foundation in coding and land your dream Tech job I create practical no fluff tutorials road maps and career advice to help you succeed if that sounds good hit subscribe and check out the other videos on this channel the first step to learning blockchain development is to pick up a programming language the two most popular languages for blockchain development are Python and JavaScript python is the easiest to learn and is widely used in blockchain scripting JavaScript is common for frontend development and web 3 Frameworks which we'll talk about later in this video if you're starting out stick to one language preferably python so you don't get confused after learning python picking up JavaScript will be much faster if you study and code 3 to 5 hours a day you can learn the basics of either language in about 2 months now to help you on this journey I've created a free supplementary PDF that breaks down the specific Concepts you need to learn for each skill it's a great resource to review your progress find gaps in your knowledge and prepare for interviews you can find the link in the description Box by the way I have a bunch of tutorials on this channel and complete courses on my website if you're looking for structured learning again links are in the description box the next thing you need to learn is a version control system like git git is not a programming language it's a tool we use to track changes to our code and collaborate with others git and GitHub which is a platform that hosts git repositories are essential for every developer git has a ton of features but you don't need to know them all for everyday use think of it like the 8020 rule 80% of the time you use 20% of gits features 1 to 2 weeks of practice is enough to get up and running again I have a bunch of tutorials on this channel and complete courses on my website if you prefer structured learning the next step is studying data structures and algorithms this is one of the topics taught to computer science students that a lot of self-taught developers Skip and is often asked in job interviews it's particularly important for blockchain development because in blockchain development every operation can have a cost so you have to learn how to process and store data efficiently and this is where data structures come into the play you have to use the right data structure for the right problem so make sure to study the classic data structures like arrays link lists Stacks cues and so on spend about a month or two on this and you'll be in great shape once you have a good grasp of blockchain fundamentals you're ready to learn about smart contracts these are programs that run on a blockchain like little robots that follow specific rules and can't be changed once their life now solidity is the most popular language for writing smart contracts on ethereum don't let the name scare you it's similar to other coding languages once you get the hang of it you can practice using remix IDE which is a web-based development environment for ethereum smart contracts it's great for beginners because you can start coding and testing your smart contracts immediately without extensive local setup once you get comfortable writing simple contracts with remix IDE then I would recommend learning hard hat for more professional and Enterprise level workflows it's a popular local development environment for ethereum smart contracts it gives you a framework and a set of tools to build test deploy and debug smart contracts more effectively spend about a month or two building small projects like a basic token or nft now once you build and deploy a smart contract to a blockchain network then you need to allow users to interact with it and this is where dap or decentralized application development comes into play a Dap is basically an application that looks and feels like a regular web or mobile app but instead of having a single company server at the back end it uses a blockchain network for its core operations now to build a dab you have to learn a front and framework for building user interfaces we have a few tools here like react angular and view but react is the most popular tool for building user interfaces now to learn react you need to learn JavaScript and ideally typescript which is a super cell of JavaScript that is widely used in react projects these days you can learn the essence of JavaScript and typescript in about 2 months and then you need another month or two to learn react also you should get familiar with web3 libraries like web3js or ether's JS for connecting your frontend application to the blockchain so if you dedicate a few hours every day and follow this road map you'll have the necessary knowledge to apply for an entry-level blockchain developer job in about 8 to 10 months if you have any questions please let me know in the comments and I'll do my best to answer you right here or in my future videos if you enjoy this video please give it a like And subscribe for more useful content
zVEH7Zt1j9A,"2025 is just around the corner and if you're wondering which Tech creators are going to dominate the scene you're in the right place now before we dive in let me give you one key piece of advice don't try to learn everything you can't be a data scientist a mobile developer and a devops engineer all at the same time it just doesn't work pick one path focus and learn the skills that career demands I've created detailed road maps for many of the careers we're about to discuss you'll find the links in the description below let's kick things off with AI and machine learning these are the rock stars of tech right now transforming Industries like healthcare finance and transportation take self-driving cars for example AI Engineers are the ones building the models that make these cars smarter every day the salary for a machine learning engineer is about $120,000 to $180,000 a year depending on your skills and location oh and if you're serious about this pass I've got a detailed road map for AI and machine learning Engineers check it out below the next career on our list is data scientist data science scientists are the detectives of the tech World they take raw data and turn it into actionable insights think about Netflix recommending your next favorite show or Spotify cating playlist just for you that's data science in action it's not just about crunching numbers it's about understanding the story the data is telling the salary for a data scientist is around $100,000 to $150,000 and of course that depends on your skill and location and yes I've got a road map for data scientists as well link is in the description the next career on our list is cyber security specialist cyber security is like being a digital bodyguard with cyber attacks increasing every year this role is absolutely critical a friend of mine works in cyber security for a bank and he once told me they get hit by thousands of attack attempts every single day companies can't afford to take risks so they're paying top dollar for experts in this field the salary for a cyber security specialist is around 90,000 to1 150,000 and even higher if you specialize in areas like ethical hacking"
fZmQ_aPXJAM,
AD43TVI2S0A,
AQdMaSaHWdM,
YNtWJNPCPPs,
BGZB9dn0GV4,
yVl_G-F7m8c,
c] code we have one more opportunity for improving this code look there are multiple places where we have defined our choices this is bad for two reasons one reason is that if we have a typo in our code our program is not going to work that's number one problem the second problem is that if tomorrow we decide to change our choices from R S and P to something else like 1 2 and three there are multiple places that we have to modify in programming we have this principle called dry which is short for don't repeat yourself so we don't want to have repetition or duplication in our code most of the time it's a bad practice practice so how can we solve this problem well we can generate this top hole based on this dictionary in this dictionary we have three key value pairs our keys are R S and P so let me show you how we can convert this dictionary to a tople with these values first I'm going to select this line and the rest of the code now we can convert all these lines to a comment by pressing command and slash on Mac or control and slash on Windows now all these lines are commented out so they're not going to get executed we only have the Declaration of our dictionary now let's print emojis dot look here we have a method called keys which Returns the keys of this dictionary using this structure dict keys let me show you so back to the terminal let's run our program all right here's what we get we get an object of type dict keys or dictionary keys and here we have R S and P but this is not exactly what we want what we want is a topple but this is very easy to fix we can pass the object that is returned from this method to the topple function and with this we get a top hole exactly like the top hole that we declared here so we can set choices to top hole of emojis do Keys okay with this technique we remov duplication in our code now let's bring back all the code here so one more time we press command and slash on Mac or control and slash on Windows okay now look there are other places where we have repeated our choices again if we have a typo our program is not going to work so realistically we need a single place for defining our choices to do that we can go to the top and declare a bunch of constants by convention we use uppercase letters to declare constants so we can declare a constant like rock and set it to R similarly scissors and paper this is a single place where we declare our choices now anywhere we have R S and P we replace them with our constants so I have selected R here now to select the next occurrence of R in this code we press command and D on Mac or control and D on Windows look this instance is also selected one more time we press command and D there you go now we have three cursors all of them selecting R so we can replace them all with rock in one go now to cancel multic cursor editing we press the escape button twice okay one more time we're going to select s we press command and D twice to select these two instances as well and replace this with scissors again we press the skape button twice done and the last one paper okay now we have a single place where we have defined our choices so no chance for typos and if we decide to change the choices from RS and P to something else in the future there is a single place we have to update we can change this to one two and three and everything will work okay but there is another benefit here look down here where we determine the winner our code is more descriptive so instead of comparing user choice and computer Choice with r and s we can clearly see that if the user has a rock and the computer has scissors the user is the winner hey there I hope you've been enjoying this video so far if you're finding this helpful and want to take your python skills even further I've got something really exciting for you this video is just a taste of what you will find in my full course python projects for beginners in the full course we dive deep into more projects covering a wide range of Concepts that will help you sharpen your problem solving skills and become a confident python programmer if you're ready to level up check out the link below to get access to the full course I would love to see you there and help you on your python Journey all right for our next project we're going to build a QR code generator so first we enter some text or URL I'm going to enter the address of my website code with mos.com next we enter a file name let's enter m.jpg now we have a QR code saved in this file this file is right here so this is the QR code for my we it if you scan this with your phone it will open your browser and take you to my website now to build this we're going to use a thirdparty library called QR code so head over to p.org proqr code read the documentation for this Library the purpose of this project is to get you familiar with using thirdparty libraries so this project doesn't have really complex logic it's all about the right way to use third party packages so I spend a few minutes to go through the documentation then install this library and build this project all right the first thing we're going to do is set up a virtual environment a virtual environment in Python is like a separate isolated workspace on your computer where you can install packages and run python projects think of it as a clean organized room that's separate from the rest of your house in this room you have everything you need to work on a specific Project without affecting anything else in the house now why do we need a virtual environment well imagine you're working on two different python projects one project needs an older version of a library and the other project needs a newer version if you install both versions globally for the whole computer they might conflict with each other a virtual environment solves this problem by allowing each project to have its own separate environment with its own specific versions of libraries okay so to set up a virtual environment here we open the terminal window and type python if you're on Windows or Python 3 if you're on Mac then we type-m that is short for module we're going to run this module VM that's one of the built-in modules in Python for creating virtual environments and then we specify a name for our virtual environment by convention we often use VMV as well okay now vs code is saying we noticed a new virtual environment has been created do you want to selected for the workspace folder for now select no we come back to this later now take a look at the project directory we have this new folder here VM and inside this we have a bunch of folders like bin include and lip inside the bin folder we have executables like pip pip 3 python python 3 and so on now if you're a bit more experienced and are familiar with Git You can see that we have over a th000 files ready to be committed to our Repository we don't want to include these files in our repository so to exclude them here in the root of our project we add a new file called dogit ignore in this file we add the files and folders We want to exclude from our git repository in this case VN folder so we add a forward slash here okay now if you're not familiar with Git don't worry about it just ignore this step for now okay so we have created a virtual environment but current L it's not active so we go back to the terminal to activate it if you're on Windows you type VM back slash scripts back slash activate if you're on Mac you type Source VN slash bin SL activate Okay now look this virtual environment is activated so any packages that we install will be installed in this virtual environment or in this isolated workspace when we are done with this project we can deactivate this virtual environment by typing deactivate okay now let's activate it one more time good now in this virtual environment we're going to install the QR code package all right good with this installed now we add a new file to our project QR code generator. Pi first we import the QR code module next we use the input function and tell the user to enter some text or URL we get the result and store it in a variable called Data next we use the input function to get a file name so enter the file name and rest store it here now it's a good practice to remove any white spaces around what the user types for example what if the user types let's say the address of my website as the URL whether they type this address or this address followed by a whites space we want to have the same QR code generator so over here we can call the strip method to get rid of any white spaces around our data okay similarly I would like to strip any white spaces around the file name good now we ready to generate our QR code to do that we go in the QR code module and create create a QR code object here we want to set two parameters one is box size I'm going to set it to 10 these are just arbitrary values I'm going to set border to four this returns a QR code object we store it in this variable next we call qr. add data then we pass our data next we call qr. make image and set two arguments here one is fill color which I'm going to set to Black again these are arbitrary values you can use any colors you want we also set back color to white this returns an image that we store in a variable and finally we call image. saave to save it in this file and at the end we print QR code saved as now here we want to add the file name so let's convert this to a formatted string and insert the file name here now let's run our program so I'm going to enter the address of my website code with m.com and for the file name I'm going to enter m.jpg okay now look in this folder we have mh. jpg this is my QR code so if you point your phone at this and scan it this will open your browser and take you to my website hey there I hope you've been enjoying this video so far if if you're finding this helpful and want to take your python skills even further I've got something really exciting for you this video is just a taste of what you will find in my full course python projects for beginners in the full course we dive deep into more projects covering a wide range of Concepts that will help you sharpen your problem solving skills and become a confident python programmer if you're ready to level up check out the link below to get access to the full course I would love to see you there and help you on your python Journey,
6GQRb4fGvtk,
YRJbhFLLPyE,
9R3X0JoCLyU,
GxmfcnU3feo,
7IgVGSaQPaw,
3ZEMvvDFEdA,
yye7rSsiV6k,
IQDA39A44AA,
CxLdTIIMXuM,
OeEHJgzqS1k,
Tef1e9FiSR0,
J-graiyPhpw,
3WphgC4wq0I,
7IoNR3q2Jcc,
tdFsel6-bgo,
8jP78iP6zVM,
Zl1hnNOAbFQ,
cVMh0SIjp9k,
iw0znRuaYL8,
KkmSR7c9qLc,
4gX44uyGSHo,
FW49JfEXI3E,
Vrtx9G9lEuM,
vE7Cy5csYbQ,
nzzPMc1X_gM,
27YP6n6pDh0,
kJOqIaGwQ7Y,
E9BXvDElDlw,
#NAME?,
